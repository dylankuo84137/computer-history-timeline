<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>電腦科技發展歷史時間軸</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .timeline-background {
            background: linear-gradient(to right, #f8fafc, #f1f5f9);
        }
        .resizer {
            background: #e5e7eb;
            cursor: ns-resize;
            height: 8px;
            position: relative;
        }
        .resizer:hover {
            background: #9ca3af;
        }
        .resizer::after {
            content: '⋯⋯⋯';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b7280;
            font-size: 12px;
            letter-spacing: 2px;
        }
        .card-dragging {
            opacity: 0.8;
            transform: rotate(5deg) scale(1.1);
            z-index: 1000;
            position: fixed;
            pointer-events: none;
        }
        .touch-drag-preview {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }
        
        /* 防止觸控時的文字選取 */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Color configuration for sticky note cards
        const stickyColors = [
          { bg: 'bg-yellow-200', border: 'border-yellow-400', hover: 'hover:bg-yellow-300' },
          { bg: 'bg-pink-200', border: 'border-pink-400', hover: 'hover:bg-pink-300' },
          { bg: 'bg-blue-200', border: 'border-blue-400', hover: 'hover:bg-blue-300' },
          { bg: 'bg-green-200', border: 'border-green-400', hover: 'hover:bg-green-300' },
          { bg: 'bg-purple-200', border: 'border-purple-400', hover: 'hover:bg-purple-300' },
          { bg: 'bg-orange-200', border: 'border-orange-400', hover: 'hover:bg-orange-300' },
          { bg: 'bg-indigo-200', border: 'border-indigo-400', hover: 'hover:bg-indigo-300' },
          { bg: 'bg-red-200', border: 'border-red-400', hover: 'hover:bg-red-300' }
        ];

        // Configuration data
        const configData = {
          historyCards: [
            // 17th Century Computing Machines (1600s)
            { id: 'card-17th-1', type: '人物', name: '理查·布雷斯韋特', year: 1613, description: '首次記錄「電腦 (computer)」一詞，當時指從事計算工作的人，而非機器。', hint: '首次定義「電腦」概念的人', colorIndex: 2 },
            { id: 'card-17th-2', type: '人物', name: '布萊茲·帕斯卡', year: 1642, description: '發明手搖計算器 (Pascaline)，最初只能做加法，後來改良可做減法和乘法。', hint: '發明第一台機械計算器', colorIndex: 3 },
            { id: 'card-17th-3', type: '人物', name: '戈特弗里德·萊布尼茲', year: 1694, description: '建造了步進計算器 (Step Reckoner)，第一台可以自動執行加減乘除四種運算的機器，並發明了萊布尼茲輪。', hint: '四則運算計算機發明者', colorIndex: 4 },
            
            // 19th Century Babbage Era (1800s)
            { id: 'card-babbage-1', type: '人物', name: '查爾斯·巴貝奇', year: 1822, description: '電腦之父，提出差分計算機設計，旨在自動化微積分計算以生產可靠的數學表格。', hint: '被稱為「電腦之父」', colorIndex: 5 },
            { id: 'card-babbage-2', type: '發明', name: '分析機 (Analytical Engine)', year: 1837, description: '巴貝奇設計的通用計算機起點，具備資料儲存、運算、輸入和輸出的概念，是現代電腦架構的先驅。', hint: '第一台通用計算機概念', colorIndex: 6 },
            { id: 'card-ada-1', type: '人物', name: '愛達·勒芙蕾絲', year: 1833, description: '17歲時在巴貝奇的沙龍中認識了他，對差分機展現出極大興趣，開啟了程式設計史。', hint: '世界第一位程式設計師', colorIndex: 7 },
            { id: 'card-ada-2', type: '發明', name: '第一個電腦程式', year: 1843, description: '愛達·勒芙蕾絲為分析機編寫計算白努利數的演算法，使用了迴圈和次常式等現代程式設計技巧，被視為史上第一個公開發表的電腦程式。', hint: '史上第一個電腦程式', colorIndex: 0 },
            { id: 'card-diff-2', type: '發明', name: '差分機二號', year: 1847, description: '巴貝奇設計的零件更精簡、可計算31位數的差分機，展現了機械計算的極致。', hint: '精密機械計算機', colorIndex: 1 },
            { id: 'card-scheutz', type: '人物', name: '佩爾·格奧爾格·舒茲', year: 1855, description: '瑞典發明家，受巴貝奇啟發成功建造並在巴黎萬國博覽會展出全尺寸差分機。', hint: '成功建造差分機的發明家', colorIndex: 2 },
            
            // Beginning of Electrical Era (Late 1800s)
            { id: 'card-tesla', type: '人物', name: '尼古拉·特斯拉', year: 1888, description: '發明高頻交流發電機，使人類正式邁入電氣時代，為後來的電子計算機奠定基礎。', hint: '電氣時代的開創者', colorIndex: 3 },
            { id: 'card-hollerith', type: '人物', name: '赫爾曼·何樂禮', year: 1890, description: '現代機械數據處理之父，為美國人口普查設計了電力製表系統，利用打孔卡和電路元件，比人工計算快約10倍。', hint: '機械數據處理之父', colorIndex: 4 },
            
            // 20th Century Theoretical Foundation (1900s-1930s)
            { id: 'card-ibm', type: '發明', name: 'IBM公司成立', year: 1924, description: '何樂禮的製表機械公司最終發展為萬國商業機械公司 (IBM)，成為電腦產業的重要推手。', hint: '電腦巨頭公司的誕生', colorIndex: 5 },
            { id: 'card-turing', type: '人物', name: '艾倫·圖靈', year: 1936, description: '提出圖靈機概念，為現代電腦科學和人工智慧奠定了理論基礎。', hint: '電腦科學理論之父', colorIndex: 6 },
            { id: 'card-shannon', type: '人物', name: '克勞德·夏農', year: 1937, description: '21歲時發表《繼電器和開關電路的符號分析》論文，被視為數位計算機理論和數位電路設計理論的創始人。', hint: '數位電路設計理論創始人', colorIndex: 7 },
            { id: 'card-ww2', type: '發明', name: '二戰推動電腦發展', year: 1939, description: '第二次世界大戰的爆發推動了軍事和科技競爭，促成了第一台電子電腦的誕生。', hint: '促成電子電腦誕生的戰爭', colorIndex: 0 },
            
            // Electronic Computer Era (1940s-1950s)
            { id: 'card-neumann', type: '人物', name: '約翰·馮·諾伊曼', year: 1945, description: '提出馮諾伊曼架構，這個架構至今仍是大多數電腦系統的基礎設計原理。', hint: '現代電腦架構設計者', colorIndex: 1 },
            { id: 'card-eniac', type: '發明', name: 'ENIAC', year: 1946, description: '第一台真正的電子數位計算機，重達30噸，占地167平方米，標誌著電腦時代的開始。', hint: '第一台電子數位計算機', colorIndex: 2 },
            { id: 'card-transistor', type: '發明', name: '電晶體', year: 1947, description: '貝爾實驗室發明，取代真空管的革命性發明，使電腦變得更小、更快、更可靠。', hint: '取代真空管的革命發明', colorIndex: 3 },
            { id: 'card-univac', type: '發明', name: 'UNIVAC I', year: 1951, description: '第一台商用電腦，成功預測了艾森豪威爾的總統選舉勝利，向公眾展示了電腦的威力。', hint: '第一台商用電腦', colorIndex: 4 },
            { id: 'card-ada-reprint', type: '發明', name: '愛達筆記再版', year: 1953, description: '愛達·勒芙蕾絲關於巴貝奇分析機的筆記被重新出版，提升了其在電腦發展史上的地位。', hint: '程式設計史經典重現', colorIndex: 5 },
            
            // Modern Computer Development (1950s-1970s)
            { id: 'card-ic', type: '發明', name: '集成電路', year: 1958, description: '德州儀器發明，將多個電晶體集成在一個晶片上，大幅提升了電腦的性能和可靠性。', hint: '微電子技術重要突破', colorIndex: 6 },
            { id: 'card-mouse', type: '發明', name: '電腦滑鼠', year: 1964, description: '道格拉斯·恩格爾巴特發明，革命性地改變了人機互動方式，讓電腦更容易使用。', hint: '改變人機互動的設備', colorIndex: 7 },
            { id: 'card-moore', type: '人物', name: '戈登·摩爾', year: 1965, description: '英特爾創辦人，提出摩爾定律，預測晶片性能每兩年翻倍，至今仍指導著半導體產業。', hint: '預測晶片發展的定律提出者', colorIndex: 0 },
            { id: 'card-arpanet', type: '發明', name: 'ARPANET', year: 1969, description: '網際網路的前身，第一個封包交換網路，連接了四所美國大學，開啟了網路時代。', hint: '網際網路的前身', colorIndex: 1 },
            
            // Microcomputer Revolution (1970s-1980s)
            { id: 'card-microprocessor', type: '發明', name: '微處理器', year: 1971, description: 'Intel 4004，第一款商用微處理器，開創了個人電腦時代的技術基礎。', hint: '個人電腦時代的核心技術', colorIndex: 2 },
            { id: 'card-floppy', type: '發明', name: '軟碟', year: 1971, description: 'IBM發明，提供了可攜式資料儲存方式，讓程式和資料能在不同電腦間轉移。', hint: '第一種可攜式儲存媒體', colorIndex: 3 },
            { id: 'card-gates', type: '人物', name: '比爾·蓋茲', year: 1975, description: 'Microsoft創辦人，推動了個人電腦軟體的普及，讓電腦成為每個人都能使用的工具。', hint: '軟體巨頭公司創辦人', colorIndex: 4 },
            { id: 'card-jobs', type: '人物', name: '史蒂夫·賈伯斯', year: 1976, description: '蘋果電腦創辦人，以用戶體驗為中心的設計理念，革命性地改變了個人電腦產業。', hint: '重視設計的電腦公司創辦人', colorIndex: 5 },
            { id: 'card-apple2', type: '發明', name: 'Apple II', year: 1977, description: '第一台成功的個人電腦，配備彩色顯示和聲音功能，讓電腦走入家庭。', hint: '成功的家用個人電腦', colorIndex: 6 },
            { id: 'card-ada-lang', type: '發明', name: 'Ada程式語言', year: 1980, description: '美國國防部將其電腦程式語言以「Ada」命名，以紀念愛達·勒芙蕾絲這位世界第一位程式設計師。', hint: '紀念首位程式設計師的語言', colorIndex: 7 },
            
            // Personal Computer Popularization (1980s-1990s)
            { id: 'card-ibm-pc', type: '發明', name: 'IBM PC', year: 1981, description: '建立了個人電腦的工業標準，開創了PC兼容機的時代。', hint: '個人電腦工業標準制定者', colorIndex: 0 },
            { id: 'card-lotus', type: '發明', name: 'Lotus 1-2-3', year: 1983, description: 'IBM PC的第一個殺手級應用程式，電子試算表軟體，推動了商業電腦化。', hint: '第一個殺手級應用程式', colorIndex: 1 },
            { id: 'card-mac', type: '發明', name: 'Macintosh', year: 1984, description: '第一台成功商業化的圖形使用者介面電腦，改變了人與電腦的互動方式。', hint: '圖形介面的先驅電腦', colorIndex: 2 },
            { id: 'card-windows', type: '發明', name: 'Windows 1.0', year: 1985, description: 'Microsoft推出的第一個圖形使用者介面作業系統，讓DOS電腦也能使用圖形界面。', hint: '普及圖形介面的作業系統', colorIndex: 3 },
            
            // Internet Era (1990s-2000s)
            { id: 'card-www', type: '發明', name: 'World Wide Web', year: 1989, description: '提姆·柏納斯-李發明萬維網，徹底改變了資訊傳播方式，開啟了網際網路時代。', hint: '改變世界的網路發明', colorIndex: 4 },
            { id: 'card-linux', type: '發明', name: 'Linux', year: 1991, description: '林納斯·托瓦茲開發的開源作業系統，推動了開源軟體運動，成為伺服器主流系統。', hint: '開源軟體運動的代表', colorIndex: 5 },
            { id: 'card-mosaic', type: '發明', name: 'Mosaic瀏覽器', year: 1993, description: '第一個圖形化網頁瀏覽器，讓一般大眾能夠輕鬆使用網際網路。', hint: '第一個圖形化瀏覽器', colorIndex: 6 },
            { id: 'card-google', type: '發明', name: 'Google搜尋引擎', year: 1998, description: '改變資訊檢索方式，讓網路上的龐大資訊變得易於搜尋和存取。', hint: '改變搜尋方式的引擎', colorIndex: 7 },
            
            // Mobile and Cloud Era (2000s-2010s)
            { id: 'card-iphone', type: '發明', name: 'iPhone', year: 2007, description: '蘋果推出的智慧手機，觸控螢幕和直觀介面革命性地改變了行動通訊。', hint: '觸控革命的智慧手機', colorIndex: 0 },
            { id: 'card-android', type: '發明', name: 'Android', year: 2008, description: 'Google開發的開源行動作業系統，推動了智慧手機的普及。', hint: '開源的行動作業系統', colorIndex: 1 },
            { id: 'card-ipad', type: '發明', name: 'iPad', year: 2010, description: '開創了平板電腦市場，改變了人們消費媒體內容和輕度計算的方式。', hint: '開創平板電腦市場', colorIndex: 2 },
            
            // AI and Modern Technology (2020s)
            { id: 'card-chatgpt', type: '發明', name: 'ChatGPT', year: 2022, description: 'OpenAI推出的對話式AI，讓人工智慧技術進入大眾生活，開啟AI時代。', hint: '對話式AI進入大眾生活', colorIndex: 3 }
          ]
        };

        const ComputerHistoryTimeline = () => {
          const [timelineScale, setTimelineScale] = useState(1);
          const [timelineOffset, setTimelineOffset] = useState(0);
          const [cards, setCards] = useState(configData.historyCards);
          const [placedCards, setPlacedCards] = useState([]);
          const [draggedCard, setDraggedCard] = useState(null);
          const [isDragging, setIsDragging] = useState(false);
          const [popupCard, setPopupCard] = useState(null);
          const [popupPosition, setPopupPosition] = useState({ x: 0, y: 0 });
          const [isTimelineDragging, setIsTimelineDragging] = useState(false);
          const [dragStart, setDragStart] = useState({ x: 0, offset: 0 });
          const [errorMessage, setErrorMessage] = useState('');
          const [timelineHeight, setTimelineHeight] = useState(60);
          const [isResizing, setIsResizing] = useState(false);
          const timelineRef = useRef(null);
          
          // 觸控拖拽相關狀態
          const [touchDragCard, setTouchDragCard] = useState(null);
          const [touchDragPosition, setTouchDragPosition] = useState({ x: 0, y: 0 });
          const [touchStartPosition, setTouchStartPosition] = useState({ x: 0, y: 0 });
          const [isTouchDragging, setIsTouchDragging] = useState(false);
          
          // 觸控縮放相關狀態
          const [lastTouchDistance, setLastTouchDistance] = useState(0);
          const [lastTouchCenter, setLastTouchCenter] = useState({ x: 0, y: 0 });

          const minYear = 1600;
          const maxYear = 2030;
          const yearRange = maxYear - minYear;

          // 初始化時間軸顯示整個年份範圍
          useEffect(() => {
            if (timelineRef.current && timelineScale === 1 && timelineOffset === 0) {
              const containerWidth = timelineRef.current.clientWidth;
              const timelineWidth = 2000 * timelineScale;
              
              // 如果時間軸比容器寬，則居中顯示
              if (timelineWidth > containerWidth) {
                const centerOffset = (containerWidth - timelineWidth) / 2;
                setTimelineOffset(centerOffset);
              } else {
                // 如果時間軸比容器窄，則調整縮放以適應容器
                const newScale = containerWidth / 2000;
                setTimelineScale(newScale);
                setTimelineOffset(0);
              }
            }
          }, [timelineRef.current]);

          // 計算兩點間距離（用於觸控縮放）
          const getTouchDistance = (touch1, touch2) => {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
          };

          // 計算兩點中心（用於觸控縮放）
          const getTouchCenter = (touch1, touch2) => {
            return {
              x: (touch1.clientX + touch2.clientX) / 2,
              y: (touch1.clientY + touch2.clientY) / 2
            };
          };

          // Generate dynamic year markers based on zoom level
          const generateYearMarkers = () => {
            let interval;
            
            if (timelineScale >= 2.5) {
              interval = 10;
            } else if (timelineScale >= 1.5) {
              interval = 25;
            } else if (timelineScale >= 0.8) {
              interval = 50;
            } else {
              interval = 100;
            }
            
            const markers = [];
            const startYear = Math.ceil(minYear / interval) * interval;
            
            for (let year = startYear; year <= maxYear; year += interval) {
              markers.push(year);
            }
            
            return markers;
          };

          const dynamicYearMarkers = generateYearMarkers();

          const yearToPixel = (year) => {
            const ratio = (year - minYear) / yearRange;
            return ratio * 2000 * timelineScale + timelineOffset;
          };

          const pixelToYear = (pixel) => {
            const ratio = (pixel - timelineOffset) / (2000 * timelineScale);
            return Math.round(minYear + ratio * yearRange);
          };

          // 處理滑鼠滾輪縮放
          const handleTimelineZoom = (event) => {
            event.preventDefault();
            const delta = event.deltaY * -0.001;
            const newScale = Math.max(0.5, Math.min(3, timelineScale + delta));
            
            if (newScale !== timelineScale && timelineRef.current) {
              const rect = timelineRef.current.getBoundingClientRect();
              const mouseX = event.clientX - rect.left;
              const scaleRatio = newScale / timelineScale;
              const newOffset = mouseX - (mouseX - timelineOffset) * scaleRatio;
              
              setTimelineScale(newScale);
              setTimelineOffset(newOffset);
            }
          };

          // 處理觸控縮放開始
          const handleTouchStart = (e) => {
            if (e.touches.length === 2) {
              // 雙指觸控縮放
              e.preventDefault();
              const distance = getTouchDistance(e.touches[0], e.touches[1]);
              const center = getTouchCenter(e.touches[0], e.touches[1]);
              setLastTouchDistance(distance);
              setLastTouchCenter(center);
            } else if (e.touches.length === 1) {
              // 單指拖拽時間軸（如果點擊在時間軸背景上）
              if (e.target === timelineRef.current || e.target.classList.contains('timeline-background')) {
                setIsTimelineDragging(true);
                setDragStart({
                  x: e.touches[0].clientX,
                  offset: timelineOffset
                });
                setPopupCard(null);
              }
            }
          };

          // 處理觸控縮放移動
          const handleTouchMove = (e) => {
            if (e.touches.length === 2) {
              // 雙指縮放
              e.preventDefault();
              const distance = getTouchDistance(e.touches[0], e.touches[1]);
              const center = getTouchCenter(e.touches[0], e.touches[1]);
              
              if (lastTouchDistance > 0 && timelineRef.current) {
                const scaleChange = distance / lastTouchDistance;
                const newScale = Math.max(0.5, Math.min(3, timelineScale * scaleChange));
                
                if (newScale !== timelineScale) {
                  const rect = timelineRef.current.getBoundingClientRect();
                  const centerX = center.x - rect.left;
                  const scaleRatio = newScale / timelineScale;
                  const newOffset = centerX - (centerX - timelineOffset) * scaleRatio;
                  
                  setTimelineScale(newScale);
                  setTimelineOffset(newOffset);
                }
                
                setLastTouchDistance(distance);
                setLastTouchCenter(center);
              }
            } else if (e.touches.length === 1 && isTimelineDragging) {
              // 單指拖拽時間軸
              const deltaX = e.touches[0].clientX - dragStart.x;
              setTimelineOffset(dragStart.offset + deltaX);
            }
          };

          // 處理觸控結束
          const handleTouchEnd = (e) => {
            if (e.touches.length < 2) {
              setLastTouchDistance(0);
            }
            if (e.touches.length === 0) {
              setIsTimelineDragging(false);
            }
          };

          // 處理卡片觸控開始
          const handleCardTouchStart = (e, card) => {
            e.preventDefault();
            e.stopPropagation();
            
            const touch = e.touches[0];
            setTouchDragCard(card);
            setTouchStartPosition({ x: touch.clientX, y: touch.clientY });
            setTouchDragPosition({ x: touch.clientX, y: touch.clientY });
            setIsTouchDragging(false);
            setPopupCard(null);
          };

          // 處理卡片觸控移動
          const handleCardTouchMove = (e) => {
            if (!touchDragCard) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartPosition.x);
            const deltaY = Math.abs(touch.clientY - touchStartPosition.y);
            
            // 如果移動距離超過閾值，開始拖拽
            if (!isTouchDragging && (deltaX > 10 || deltaY > 10)) {
              setIsTouchDragging(true);
              setIsDragging(true);
              setDraggedCard(touchDragCard);
            }
            
            if (isTouchDragging) {
              setTouchDragPosition({ x: touch.clientX, y: touch.clientY });
            }
          };

          // 處理卡片觸控結束
          const handleCardTouchEnd = (e) => {
            if (!touchDragCard) return;
            
            e.preventDefault();
            
            if (isTouchDragging && timelineRef.current) {
              // 檢查是否放置在時間軸上
              const timelineRect = timelineRef.current.getBoundingClientRect();
              const touch = e.changedTouches[0];
              
              if (touch.clientY >= timelineRect.top && touch.clientY <= timelineRect.bottom &&
                  touch.clientX >= timelineRect.left && touch.clientX <= timelineRect.right) {
                
                const dropX = touch.clientX - timelineRect.left;
                const dropYear = pixelToYear(dropX);
                const correctYear = touchDragCard.year;
                const yearDifference = Math.abs(dropYear - correctYear);
                
                if (yearDifference <= 25) {
                  // 正確放置
                  if (cards.find(card => card.id === touchDragCard.id)) {
                    setCards(cards.filter(card => card.id !== touchDragCard.id));
                    const newCard = { ...touchDragCard, placedYear: correctYear };
                    setPlacedCards([...placedCards, newCard]);
                    
                    setTimeout(() => {
                      const cardPixelX = yearToPixel(correctYear);
                      setPopupPosition({
                        x: timelineRect.left + cardPixelX,
                        y: timelineRect.top + timelineRect.height * 0.3
                      });
                      setPopupCard(newCard);
                    }, 100);
                  }
                } else {
                  // 錯誤放置
                  setErrorMessage(`請嘗試將「${touchDragCard.name}」放置到更接近其正確年代的位置！正確年代是${correctYear}年。`);
                }
              }
            } else if (!isTouchDragging) {
              // 如果沒有拖拽，則視為點擊
              if (placedCards.find(c => c.id === touchDragCard.id)) {
                // 顯示彈窗
                const rect = e.target.getBoundingClientRect();
                setPopupPosition({
                  x: rect.left + rect.width / 2,
                  y: rect.top - 10
                });
                setPopupCard(touchDragCard);
              }
            }
            
            // 重置觸控狀態
            setTouchDragCard(null);
            setIsTouchDragging(false);
            setIsDragging(false);
            setDraggedCard(null);
          };

          // Handle timeline drag start
          const handleTimelineMouseDown = (e) => {
            if (e.target === timelineRef.current || e.target.classList.contains('timeline-background')) {
              setIsTimelineDragging(true);
              setDragStart({
                x: e.clientX,
                offset: timelineOffset
              });
              setPopupCard(null);
            }
          };

          // Handle timeline drag move
          const handleTimelineMouseMove = (e) => {
            if (isTimelineDragging) {
              const deltaX = e.clientX - dragStart.x;
              setTimelineOffset(dragStart.offset + deltaX);
            }
          };

          // Handle timeline drag end
          const handleTimelineMouseUp = () => {
            setIsTimelineDragging(false);
          };

          // Handle resizer drag
          const handleResizerMouseDown = (e) => {
            setIsResizing(true);
            e.preventDefault();
          };

          const handleResizerMouseMove = (e) => {
            if (isResizing) {
              const windowHeight = window.innerHeight;
              const headerHeight = 120;
              const newHeight = ((e.clientY - headerHeight) / (windowHeight - headerHeight)) * 100;
              setTimelineHeight(Math.max(30, Math.min(80, newHeight)));
            }
          };

          const handleResizerMouseUp = () => {
            setIsResizing(false);
          };

          // Add global event listeners
          useEffect(() => {
            if (isTimelineDragging) {
              document.addEventListener('mousemove', handleTimelineMouseMove);
              document.addEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'grabbing';
            } else {
              document.removeEventListener('mousemove', handleTimelineMouseMove);
              document.removeEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'default';
            }

            return () => {
              document.removeEventListener('mousemove', handleTimelineMouseMove);
              document.removeEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'default';
            };
          }, [isTimelineDragging, dragStart]);

          // Add resizer event listeners
          useEffect(() => {
            if (isResizing) {
              document.addEventListener('mousemove', handleResizerMouseMove);
              document.addEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'ns-resize';
            } else {
              document.removeEventListener('mousemove', handleResizerMouseMove);
              document.removeEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'default';
            }

            return () => {
              document.removeEventListener('mousemove', handleResizerMouseMove);
              document.removeEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'default';
            };
          }, [isResizing]);

          // Auto-hide error message after 3 seconds
          useEffect(() => {
            if (errorMessage) {
              const timer = setTimeout(() => {
                setErrorMessage('');
              }, 3000);
              return () => clearTimeout(timer);
            }
          }, [errorMessage]);

          // Handle drag start (滑鼠拖拽)
          const handleDragStart = (e, card) => {
            setDraggedCard(card);
            setIsDragging(true);
            setPopupCard(null);
            setErrorMessage('');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', card.id);
          };

          // Handle drag end
          const handleDragEnd = () => {
            setDraggedCard(null);
            setIsDragging(false);
          };

          // Handle timeline drop (滑鼠拖拽)
          const handleTimelineDrop = (e) => {
            e.preventDefault();
            if (!draggedCard) return;

            const timelineRect = timelineRef.current.getBoundingClientRect();
            const dropX = e.clientX - timelineRect.left;
            const dropYear = pixelToYear(dropX);

            const correctYear = draggedCard.year;
            const yearDifference = Math.abs(dropYear - correctYear);
            
            if (yearDifference <= 25) {
              if (cards.find(card => card.id === draggedCard.id)) {
                setCards(cards.filter(card => card.id !== draggedCard.id));
                const newCard = { ...draggedCard, placedYear: correctYear };
                setPlacedCards([...placedCards, newCard]);
                
                setTimeout(() => {
                  const cardPixelX = yearToPixel(correctYear);
                  setPopupPosition({
                    x: timelineRect.left + cardPixelX,
                    y: timelineRect.top + timelineRect.height * 0.3
                  });
                  setPopupCard(newCard);
                }, 100);
              }
            } else {
              setErrorMessage(`請嘗試將「${draggedCard.name}」放置到更接近其正確年代的位置！正確年代是${correctYear}年。`);
            }

            setDraggedCard(null);
            setIsDragging(false);
          };

          // Handle library drop
          const handleLibraryDrop = (e) => {
            e.preventDefault();
            if (!draggedCard || cards.find(card => card.id === draggedCard.id)) return;

            setPlacedCards(placedCards.filter(card => card.id !== draggedCard.id));
            setCards([...cards, draggedCard]);
            setPopupCard(null);

            setDraggedCard(null);
            setIsDragging(false);
          };

          // Prevent default drag behaviors
          const handleDragOver = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          };

          const handleDragEnter = (e) => {
            e.preventDefault();
          };

          const handleDragLeave = (e) => {
            e.preventDefault();
          };

          // Handle card click to show popup (只用於滑鼠點擊)
          const handleCardClick = (e, card) => {
            e.stopPropagation();
            if (isTimelineDragging) return;
            
            if (placedCards.find(c => c.id === card.id)) {
              const rect = e.currentTarget.getBoundingClientRect();
              setPopupPosition({
                x: rect.left + rect.width / 2,
                y: rect.top - 10
              });
              setPopupCard(card);
            }
          };

          // Close popup
          const closePopup = () => {
            setPopupCard(null);
          };

          // Card component
          const Card = ({ card, isPlaced = false, placedYear = null }) => {
            const colorStyle = stickyColors[card.colorIndex % stickyColors.length];
            const isCurrentlyDragging = isDragging && (draggedCard?.id === card.id || touchDragCard?.id === card.id);
            const cardScale = isPlaced ? Math.min(1.5, Math.max(0.8, timelineScale)) : 1;
            
            return (
              <div
                draggable={!('ontouchstart' in window)} // 只在非觸控設備上啟用HTML5拖拽
                onDragStart={(e) => handleDragStart(e, card)}
                onDragEnd={handleDragEnd}
                onClick={(e) => handleCardClick(e, card)}
                onTouchStart={(e) => handleCardTouchStart(e, card)}
                onTouchMove={handleCardTouchMove}
                onTouchEnd={handleCardTouchEnd}
                className={`p-3 rounded-lg shadow-md cursor-move transition-all hover:shadow-xl select-none transform hover:scale-105 no-select ${
                  colorStyle.bg
                } ${colorStyle.border} ${colorStyle.hover} ${
                  isCurrentlyDragging ? 'opacity-50 rotate-6 scale-110' : ''
                } ${isPlaced ? 'm-1' : 'm-1'}`}
                style={{
                  transform: isCurrentlyDragging 
                    ? `rotate(${Math.random() * 4 - 2}deg) scale(1.1)` 
                    : `rotate(${Math.random() * 4 - 2}deg) scale(${cardScale})`,
                  boxShadow: '0 4px 8px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08)',
                  minHeight: isPlaced ? `${80 * cardScale}px` : '90px',
                  fontSize: isPlaced ? `${cardScale * 14}px` : '14px'
                }}
              >
                <div className={`text-xs font-bold mb-1 ${
                  card.type === '人物' ? 'text-blue-800' : 'text-purple-800'
                }`}>
                  {card.type}
                </div>
                <div className="text-sm font-semibold text-gray-800 mb-1 leading-tight">{card.name}</div>
                {isPlaced && (
                  <div className="text-xs text-gray-600">
                    {placedYear || card.year}年
                  </div>
                )}
                {!isPlaced && (
                  <div className="text-xs text-gray-500 italic">
                    {card.hint}
                  </div>
                )}
              </div>
            );
          };

          // 觸控拖拽預覽
          const TouchDragPreview = () => {
            if (!isTouchDragging || !touchDragCard) return null;
            
            const colorStyle = stickyColors[touchDragCard.colorIndex % stickyColors.length];
            
            return (
              <div
                className={`touch-drag-preview p-3 rounded-lg shadow-lg ${colorStyle.bg} ${colorStyle.border}`}
                style={{
                  left: touchDragPosition.x - 50,
                  top: touchDragPosition.y - 50,
                  transform: 'rotate(5deg) scale(1.1)',
                  minHeight: '90px',
                  width: '100px'
                }}
              >
                <div className={`text-xs font-bold mb-1 ${
                  touchDragCard.type === '人物' ? 'text-blue-800' : 'text-purple-800'
                }`}>
                  {touchDragCard.type}
                </div>
                <div className="text-sm font-semibold text-gray-800 mb-1 leading-tight">{touchDragCard.name}</div>
              </div>
            );
          };

          // Popup component
          const PopupDetail = () => {
            if (!popupCard) return null;

            return (
              <>
                <div 
                  className="fixed inset-0 z-40"
                  onClick={closePopup}
                  onTouchStart={closePopup}
                />
                
                <div 
                  className="fixed z-50 bg-white rounded-lg shadow-2xl border-2 border-gray-200 p-4 max-w-xs"
                  style={{
                    left: `${popupPosition.x}px`,
                    top: `${popupPosition.y}px`,
                    transform: 'translate(-50%, -100%)',
                    boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)'
                  }}
                >
                  <div 
                    className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0"
                    style={{
                      borderLeft: '8px solid transparent',
                      borderRight: '8px solid transparent',
                      borderTop: '8px solid white'
                    }}
                  />
                  
                  <div className="mb-3">
                    <span className={`px-2 py-1 rounded text-xs font-bold ${
                      popupCard.type === '人物' ? 'bg-blue-100 text-blue-800' : 'bg-purple-100 text-purple-800'
                    }`}>
                      {popupCard.type}
                    </span>
                  </div>
                  
                  <h3 className="text-lg font-bold mb-2 text-gray-800">{popupCard.name}</h3>
                  
                  <p className="text-sm text-gray-600 mb-3">
                    年份: {popupCard.year}年
                  </p>
                  
                  <p className="text-sm text-gray-800 mb-4">{popupCard.description}</p>
                  
                  <button
                    onClick={() => {
                      setPlacedCards(placedCards.filter(card => card.id !== popupCard.id));
                      setCards([...cards, popupCard]);
                      closePopup();
                    }}
                    className="w-full px-3 py-2 bg-red-500 text-white rounded text-sm hover:bg-red-600 transition-colors"
                  >
                    移除此卡片
                  </button>
                </div>
              </>
            );
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
              {/* Header */}
              <div className="bg-white shadow-lg">
                <h1 className="text-3xl font-bold text-center py-4 text-gray-800">
                  電腦科技發展歷史時間軸
                </h1>
                <div className="text-center pb-4">
                  <span className="inline-block bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm mr-2">
                    ✨ 38張歷史卡片
                  </span>
                  <span className="inline-block bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm mr-2">
                    📅 1600-2030年電腦發展史
                  </span>
                  <span className="inline-block bg-orange-100 text-orange-800 px-3 py-1 rounded-full text-sm">
                    📱 觸控友善
                  </span>
                </div>
              </div>

              {/* Error message display */}
              {errorMessage && (
                <div className="fixed top-24 left-1/2 transform -translate-x-1/2 z-50 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded shadow-lg max-w-md">
                  <div className="flex items-center">
                    <span className="text-xl mr-2">❌</span>
                    <span>{errorMessage}</span>
                  </div>
                </div>
              )}

              <div className="flex flex-col h-screen">
                {/* Timeline area */}
                <div className="p-6" style={{ height: `${timelineHeight}vh` }}>
                  <div className="bg-white rounded-lg shadow-lg h-full">
                    <div className="p-4 border-b">
                      <h2 className="text-xl font-bold">⏰ 時間軸</h2>
                      <p className="text-sm text-gray-600">
                        根據提示拖拽卡片到正確的時間位置 • 點擊已放置的卡片查看詳情 • 滑鼠滾輪或雙指縮放 • 拖拽時間軸平移
                      </p>
                    </div>
                    
                    <div 
                      className={`relative overflow-hidden flex-1 timeline-background no-select ${
                        isTimelineDragging ? 'cursor-grabbing' : 'cursor-grab'
                      }`}
                      style={{ 
                        height: 'calc(100% - 120px)',
                        background: 'linear-gradient(to right, #f8fafc, #f1f5f9)'
                      }}
                      onWheel={handleTimelineZoom}
                      onDrop={handleTimelineDrop}
                      onDragOver={handleDragOver}
                      onDragEnter={handleDragEnter}
                      onDragLeave={handleDragLeave}
                      onMouseDown={handleTimelineMouseDown}
                      onTouchStart={handleTouchStart}
                      onTouchMove={handleTouchMove}
                      onTouchEnd={handleTouchEnd}
                      onClick={closePopup}
                      ref={timelineRef}
                    >
                      {/* Timeline main line */}
                      <div 
                        className="absolute top-1/2 h-2 bg-gradient-to-r from-blue-400 to-blue-600 transform -translate-y-1/2 rounded-full shadow-md pointer-events-none"
                        style={{ 
                          left: `${timelineOffset}px`,
                          width: `${2000 * timelineScale}px`
                        }}
                      ></div>
                      
                      {/* Year markers */}
                      {dynamicYearMarkers.map(year => {
                        const xPos = yearToPixel(year);
                        const containerWidth = timelineRef.current ? timelineRef.current.clientWidth : 800;
                        if (xPos < -100 || xPos > containerWidth + 100) return null;
                        
                        return (
                          <div 
                            key={year}
                            className="absolute top-1/2 transform -translate-y-1/2 pointer-events-none"
                            style={{ left: `${xPos}px` }}
                          >
                            <div className="w-4 h-4 bg-blue-600 rounded-full -translate-x-1/2 shadow-lg border-2 border-white"></div>
                            <div className="text-sm font-bold mt-3 -translate-x-1/2 whitespace-nowrap text-center bg-white px-2 py-1 rounded shadow-sm">
                              {year}
                            </div>
                          </div>
                        );
                      })}

                      {/* Placed cards */}
                      {placedCards.map(card => {
                        const xPos = yearToPixel(card.placedYear);
                        return (
                          <div
                            key={card.id}
                            className="absolute pointer-events-auto"
                            style={{ 
                              left: `${xPos}px`, 
                              top: '30%',
                              transform: 'translateX(-50%)' 
                            }}
                            onMouseDown={(e) => e.stopPropagation()}
                            onTouchStart={(e) => e.stopPropagation()}
                          >
                            <Card card={card} isPlaced={true} placedYear={card.placedYear} />
                          </div>
                        );
                      })}
                    </div>

                    {/* Control panel */}
                    <div className="p-4 border-t bg-gray-50">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-6">
                          <span className="text-sm font-medium text-gray-600">
                            縮放: {(timelineScale * 100).toFixed(0)}%
                          </span>
                          <span className="text-xs text-gray-500">
                            💡 滑鼠滾輪/雙指縮放 • 拖拽時間軸平移 • 年份標記隨縮放自動調整
                          </span>
                        </div>
                        <button
                          onClick={() => {
                            setTimelineScale(1);
                            setTimelineOffset(0);
                          }}
                          className="px-4 py-2 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600 transition-colors shadow-sm"
                        >
                          🔄 重置時間軸
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Resizer */}
                <div 
                  className="resizer"
                  onMouseDown={handleResizerMouseDown}
                ></div>

                {/* Card library */}
                <div className="bg-white shadow-lg border-t" style={{ height: `${100 - timelineHeight}vh` }}>
                  <div 
                    className="h-full"
                    onDrop={handleLibraryDrop}
                    onDragOver={handleDragOver}
                    onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                  >
                    <div className="flex items-center justify-between p-4 bg-gradient-to-r from-gray-50 to-gray-100 border-b">
                      <h2 className="text-xl font-bold text-gray-800">📚 歷史卡片庫</h2>
                      <div className="text-sm text-gray-600">
                        剩餘 {cards.length} 張卡片
                      </div>
                    </div>
                    
                    <div className="p-6 overflow-y-auto bg-gray-50" style={{ height: 'calc(100% - 80px)' }}>
                      {cards.length === 0 ? (
                        <div className="flex items-center justify-center h-full text-gray-500 text-center">
                          <div className="bg-white rounded-lg p-8 shadow-md">
                            <div className="text-4xl mb-3">🎉</div>
                            <div className="text-lg font-medium">完成！</div>
                            <div className="text-sm">所有卡片都已正確放置到時間軸上</div>
                          </div>
                        </div>
                      ) : (
                        <div>
                          {/* Person cards section */}
                          {cards.filter(card => card.type === '人物').length > 0 && (
                            <div className="mb-6">
                              <h3 className="text-sm font-bold text-blue-800 mb-3 flex items-center">
                                👤 重要人物 ({cards.filter(card => card.type === '人物').length})
                              </h3>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
                                {cards.filter(card => card.type === '人物').map(card => (
                                  <Card key={card.id} card={card} />
                                ))}
                              </div>
                            </div>
                          )}
                          
                          {/* Invention cards section */}
                          {cards.filter(card => card.type === '發明').length > 0 && (
                            <div>
                              <h3 className="text-sm font-bold text-purple-800 mb-3 flex items-center">
                                💡 重要發明 ({cards.filter(card => card.type === '發明').length})
                              </h3>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
                                {cards.filter(card => card.type === '發明').map(card => (
                                  <Card key={card.id} card={card} />
                                ))}
                              </div>
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>

              {/* Touch drag preview */}
              <TouchDragPreview />

              {/* Popup detail */}
              <PopupDetail />
            </div>
          );
        };

        ReactDOM.render(<ComputerHistoryTimeline />, document.getElementById('root'));
    </script>
</body>
</html>
