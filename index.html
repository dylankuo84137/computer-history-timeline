<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>é›»è…¦ç§‘æŠ€ç™¼å±•æ­·å²æ™‚é–“è»¸</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .timeline-background {
            background: linear-gradient(to right, #f8fafc, #f1f5f9);
        }
        .resizer {
            background: #e5e7eb;
            cursor: ns-resize;
            height: 8px;
            position: relative;
        }
        .resizer:hover {
            background: #9ca3af;
        }
        .resizer::after {
            content: 'â‹¯â‹¯â‹¯';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b7280;
            font-size: 12px;
            letter-spacing: 2px;
        }
        .card-dragging {
            opacity: 0.8;
            transform: rotate(5deg) scale(1.1);
            z-index: 1000;
            position: fixed;
            pointer-events: none;
        }
        .touch-drag-preview {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }
        
        /* é˜²æ­¢è§¸æ§æ™‚çš„æ–‡å­—é¸å– */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Color configuration for sticky note cards
        const stickyColors = [
          { bg: 'bg-yellow-200', border: 'border-yellow-400', hover: 'hover:bg-yellow-300' },
          { bg: 'bg-pink-200', border: 'border-pink-400', hover: 'hover:bg-pink-300' },
          { bg: 'bg-blue-200', border: 'border-blue-400', hover: 'hover:bg-blue-300' },
          { bg: 'bg-green-200', border: 'border-green-400', hover: 'hover:bg-green-300' },
          { bg: 'bg-purple-200', border: 'border-purple-400', hover: 'hover:bg-purple-300' },
          { bg: 'bg-orange-200', border: 'border-orange-400', hover: 'hover:bg-orange-300' },
          { bg: 'bg-indigo-200', border: 'border-indigo-400', hover: 'hover:bg-indigo-300' },
          { bg: 'bg-red-200', border: 'border-red-400', hover: 'hover:bg-red-300' }
        ];

        // Configuration data
        const configData = {
          historyCards: [
            // 17th Century Computing Machines (1600s)
            { id: 'card-17th-1', type: 'äººç‰©', name: 'ç†æŸ¥Â·å¸ƒé›·æ–¯éŸ‹ç‰¹', year: 1613, description: 'é¦–æ¬¡è¨˜éŒ„ã€Œé›»è…¦ (computer)ã€ä¸€è©ï¼Œç•¶æ™‚æŒ‡å¾äº‹è¨ˆç®—å·¥ä½œçš„äººï¼Œè€Œéæ©Ÿå™¨ã€‚', hint: 'é¦–æ¬¡å®šç¾©ã€Œé›»è…¦ã€æ¦‚å¿µçš„äºº', colorIndex: 2 },
            { id: 'card-17th-2', type: 'äººç‰©', name: 'å¸ƒèŠèŒ²Â·å¸•æ–¯å¡', year: 1642, description: 'ç™¼æ˜æ‰‹æ–è¨ˆç®—å™¨ (Pascaline)ï¼Œæœ€åˆåªèƒ½åšåŠ æ³•ï¼Œå¾Œä¾†æ”¹è‰¯å¯åšæ¸›æ³•å’Œä¹˜æ³•ã€‚', hint: 'ç™¼æ˜ç¬¬ä¸€å°æ©Ÿæ¢°è¨ˆç®—å™¨', colorIndex: 3 },
            { id: 'card-17th-3', type: 'äººç‰©', name: 'æˆˆç‰¹å¼—é‡Œå¾·Â·èŠå¸ƒå°¼èŒ²', year: 1694, description: 'å»ºé€ äº†æ­¥é€²è¨ˆç®—å™¨ (Step Reckoner)ï¼Œç¬¬ä¸€å°å¯ä»¥è‡ªå‹•åŸ·è¡ŒåŠ æ¸›ä¹˜é™¤å››ç¨®é‹ç®—çš„æ©Ÿå™¨ï¼Œä¸¦ç™¼æ˜äº†èŠå¸ƒå°¼èŒ²è¼ªã€‚', hint: 'å››å‰‡é‹ç®—è¨ˆç®—æ©Ÿç™¼æ˜è€…', colorIndex: 4 },
            
            // 19th Century Babbage Era (1800s)
            { id: 'card-babbage-1', type: 'äººç‰©', name: 'æŸ¥çˆ¾æ–¯Â·å·´è²å¥‡', year: 1822, description: 'é›»è…¦ä¹‹çˆ¶ï¼Œæå‡ºå·®åˆ†è¨ˆç®—æ©Ÿè¨­è¨ˆï¼Œæ—¨åœ¨è‡ªå‹•åŒ–å¾®ç©åˆ†è¨ˆç®—ä»¥ç”Ÿç”¢å¯é çš„æ•¸å­¸è¡¨æ ¼ã€‚', hint: 'è¢«ç¨±ç‚ºã€Œé›»è…¦ä¹‹çˆ¶ã€', colorIndex: 5 },
            { id: 'card-babbage-2', type: 'ç™¼æ˜', name: 'åˆ†ææ©Ÿ (Analytical Engine)', year: 1837, description: 'å·´è²å¥‡è¨­è¨ˆçš„é€šç”¨è¨ˆç®—æ©Ÿèµ·é»ï¼Œå…·å‚™è³‡æ–™å„²å­˜ã€é‹ç®—ã€è¼¸å…¥å’Œè¼¸å‡ºçš„æ¦‚å¿µï¼Œæ˜¯ç¾ä»£é›»è…¦æ¶æ§‹çš„å…ˆé©…ã€‚', hint: 'ç¬¬ä¸€å°é€šç”¨è¨ˆç®—æ©Ÿæ¦‚å¿µ', colorIndex: 6 },
            { id: 'card-ada-1', type: 'äººç‰©', name: 'æ„›é”Â·å‹’èŠ™è•¾çµ²', year: 1833, description: '17æ­²æ™‚åœ¨å·´è²å¥‡çš„æ²™é¾ä¸­èªè­˜äº†ä»–ï¼Œå°å·®åˆ†æ©Ÿå±•ç¾å‡ºæ¥µå¤§èˆˆè¶£ï¼Œé–‹å•Ÿäº†ç¨‹å¼è¨­è¨ˆå²ã€‚', hint: 'ä¸–ç•Œç¬¬ä¸€ä½ç¨‹å¼è¨­è¨ˆå¸«', colorIndex: 7 },
            { id: 'card-ada-2', type: 'ç™¼æ˜', name: 'ç¬¬ä¸€å€‹é›»è…¦ç¨‹å¼', year: 1843, description: 'æ„›é”Â·å‹’èŠ™è•¾çµ²ç‚ºåˆ†ææ©Ÿç·¨å¯«è¨ˆç®—ç™½åŠªåˆ©æ•¸çš„æ¼”ç®—æ³•ï¼Œä½¿ç”¨äº†è¿´åœˆå’Œæ¬¡å¸¸å¼ç­‰ç¾ä»£ç¨‹å¼è¨­è¨ˆæŠ€å·§ï¼Œè¢«è¦–ç‚ºå²ä¸Šç¬¬ä¸€å€‹å…¬é–‹ç™¼è¡¨çš„é›»è…¦ç¨‹å¼ã€‚', hint: 'å²ä¸Šç¬¬ä¸€å€‹é›»è…¦ç¨‹å¼', colorIndex: 0 },
            { id: 'card-diff-2', type: 'ç™¼æ˜', name: 'å·®åˆ†æ©ŸäºŒè™Ÿ', year: 1847, description: 'å·´è²å¥‡è¨­è¨ˆçš„é›¶ä»¶æ›´ç²¾ç°¡ã€å¯è¨ˆç®—31ä½æ•¸çš„å·®åˆ†æ©Ÿï¼Œå±•ç¾äº†æ©Ÿæ¢°è¨ˆç®—çš„æ¥µè‡´ã€‚', hint: 'ç²¾å¯†æ©Ÿæ¢°è¨ˆç®—æ©Ÿ', colorIndex: 1 },
            { id: 'card-scheutz', type: 'äººç‰©', name: 'ä½©çˆ¾Â·æ ¼å¥§çˆ¾æ ¼Â·èˆ’èŒ²', year: 1855, description: 'ç‘å…¸ç™¼æ˜å®¶ï¼Œå—å·´è²å¥‡å•Ÿç™¼æˆåŠŸå»ºé€ ä¸¦åœ¨å·´é»è¬åœ‹åšè¦½æœƒå±•å‡ºå…¨å°ºå¯¸å·®åˆ†æ©Ÿã€‚', hint: 'æˆåŠŸå»ºé€ å·®åˆ†æ©Ÿçš„ç™¼æ˜å®¶', colorIndex: 2 },
            
            // Beginning of Electrical Era (Late 1800s)
            { id: 'card-tesla', type: 'äººç‰©', name: 'å°¼å¤æ‹‰Â·ç‰¹æ–¯æ‹‰', year: 1888, description: 'ç™¼æ˜é«˜é »äº¤æµç™¼é›»æ©Ÿï¼Œä½¿äººé¡æ­£å¼é‚å…¥é›»æ°£æ™‚ä»£ï¼Œç‚ºå¾Œä¾†çš„é›»å­è¨ˆç®—æ©Ÿå¥ å®šåŸºç¤ã€‚', hint: 'é›»æ°£æ™‚ä»£çš„é–‹å‰µè€…', colorIndex: 3 },
            { id: 'card-hollerith', type: 'äººç‰©', name: 'èµ«çˆ¾æ›¼Â·ä½•æ¨‚ç¦®', year: 1890, description: 'ç¾ä»£æ©Ÿæ¢°æ•¸æ“šè™•ç†ä¹‹çˆ¶ï¼Œç‚ºç¾åœ‹äººå£æ™®æŸ¥è¨­è¨ˆäº†é›»åŠ›è£½è¡¨ç³»çµ±ï¼Œåˆ©ç”¨æ‰“å­”å¡å’Œé›»è·¯å…ƒä»¶ï¼Œæ¯”äººå·¥è¨ˆç®—å¿«ç´„10å€ã€‚', hint: 'æ©Ÿæ¢°æ•¸æ“šè™•ç†ä¹‹çˆ¶', colorIndex: 4 },
            
            // 20th Century Theoretical Foundation (1900s-1930s)
            { id: 'card-ibm', type: 'ç™¼æ˜', name: 'IBMå…¬å¸æˆç«‹', year: 1924, description: 'ä½•æ¨‚ç¦®çš„è£½è¡¨æ©Ÿæ¢°å…¬å¸æœ€çµ‚ç™¼å±•ç‚ºè¬åœ‹å•†æ¥­æ©Ÿæ¢°å…¬å¸ (IBM)ï¼Œæˆç‚ºé›»è…¦ç”¢æ¥­çš„é‡è¦æ¨æ‰‹ã€‚', hint: 'é›»è…¦å·¨é ­å…¬å¸çš„èª•ç”Ÿ', colorIndex: 5 },
            { id: 'card-turing', type: 'äººç‰©', name: 'è‰¾å€«Â·åœ–éˆ', year: 1936, description: 'æå‡ºåœ–éˆæ©Ÿæ¦‚å¿µï¼Œç‚ºç¾ä»£é›»è…¦ç§‘å­¸å’Œäººå·¥æ™ºæ…§å¥ å®šäº†ç†è«–åŸºç¤ã€‚', hint: 'é›»è…¦ç§‘å­¸ç†è«–ä¹‹çˆ¶', colorIndex: 6 },
            { id: 'card-shannon', type: 'äººç‰©', name: 'å…‹å‹å¾·Â·å¤è¾²', year: 1937, description: '21æ­²æ™‚ç™¼è¡¨ã€Šç¹¼é›»å™¨å’Œé–‹é—œé›»è·¯çš„ç¬¦è™Ÿåˆ†æã€‹è«–æ–‡ï¼Œè¢«è¦–ç‚ºæ•¸ä½è¨ˆç®—æ©Ÿç†è«–å’Œæ•¸ä½é›»è·¯è¨­è¨ˆç†è«–çš„å‰µå§‹äººã€‚', hint: 'æ•¸ä½é›»è·¯è¨­è¨ˆç†è«–å‰µå§‹äºº', colorIndex: 7 },
            { id: 'card-ww2', type: 'ç™¼æ˜', name: 'äºŒæˆ°æ¨å‹•é›»è…¦ç™¼å±•', year: 1939, description: 'ç¬¬äºŒæ¬¡ä¸–ç•Œå¤§æˆ°çš„çˆ†ç™¼æ¨å‹•äº†è»äº‹å’Œç§‘æŠ€ç«¶çˆ­ï¼Œä¿ƒæˆäº†ç¬¬ä¸€å°é›»å­é›»è…¦çš„èª•ç”Ÿã€‚', hint: 'ä¿ƒæˆé›»å­é›»è…¦èª•ç”Ÿçš„æˆ°çˆ­', colorIndex: 0 },
            
            // Electronic Computer Era (1940s-1950s)
            { id: 'card-neumann', type: 'äººç‰©', name: 'ç´„ç¿°Â·é¦®Â·è«¾ä¼Šæ›¼', year: 1945, description: 'æå‡ºé¦®è«¾ä¼Šæ›¼æ¶æ§‹ï¼Œé€™å€‹æ¶æ§‹è‡³ä»Šä»æ˜¯å¤§å¤šæ•¸é›»è…¦ç³»çµ±çš„åŸºç¤è¨­è¨ˆåŸç†ã€‚', hint: 'ç¾ä»£é›»è…¦æ¶æ§‹è¨­è¨ˆè€…', colorIndex: 1 },
            { id: 'card-eniac', type: 'ç™¼æ˜', name: 'ENIAC', year: 1946, description: 'ç¬¬ä¸€å°çœŸæ­£çš„é›»å­æ•¸ä½è¨ˆç®—æ©Ÿï¼Œé‡é”30å™¸ï¼Œå åœ°167å¹³æ–¹ç±³ï¼Œæ¨™èªŒè‘—é›»è…¦æ™‚ä»£çš„é–‹å§‹ã€‚', hint: 'ç¬¬ä¸€å°é›»å­æ•¸ä½è¨ˆç®—æ©Ÿ', colorIndex: 2 },
            { id: 'card-transistor', type: 'ç™¼æ˜', name: 'é›»æ™¶é«”', year: 1947, description: 'è²çˆ¾å¯¦é©—å®¤ç™¼æ˜ï¼Œå–ä»£çœŸç©ºç®¡çš„é©å‘½æ€§ç™¼æ˜ï¼Œä½¿é›»è…¦è®Šå¾—æ›´å°ã€æ›´å¿«ã€æ›´å¯é ã€‚', hint: 'å–ä»£çœŸç©ºç®¡çš„é©å‘½ç™¼æ˜', colorIndex: 3 },
            { id: 'card-univac', type: 'ç™¼æ˜', name: 'UNIVAC I', year: 1951, description: 'ç¬¬ä¸€å°å•†ç”¨é›»è…¦ï¼ŒæˆåŠŸé æ¸¬äº†è‰¾æ£®è±ªå¨çˆ¾çš„ç¸½çµ±é¸èˆ‰å‹åˆ©ï¼Œå‘å…¬çœ¾å±•ç¤ºäº†é›»è…¦çš„å¨åŠ›ã€‚', hint: 'ç¬¬ä¸€å°å•†ç”¨é›»è…¦', colorIndex: 4 },
            { id: 'card-ada-reprint', type: 'ç™¼æ˜', name: 'æ„›é”ç­†è¨˜å†ç‰ˆ', year: 1953, description: 'æ„›é”Â·å‹’èŠ™è•¾çµ²é—œæ–¼å·´è²å¥‡åˆ†ææ©Ÿçš„ç­†è¨˜è¢«é‡æ–°å‡ºç‰ˆï¼Œæå‡äº†å…¶åœ¨é›»è…¦ç™¼å±•å²ä¸Šçš„åœ°ä½ã€‚', hint: 'ç¨‹å¼è¨­è¨ˆå²ç¶“å…¸é‡ç¾', colorIndex: 5 },
            
            // Modern Computer Development (1950s-1970s)
            { id: 'card-ic', type: 'ç™¼æ˜', name: 'é›†æˆé›»è·¯', year: 1958, description: 'å¾·å·å„€å™¨ç™¼æ˜ï¼Œå°‡å¤šå€‹é›»æ™¶é«”é›†æˆåœ¨ä¸€å€‹æ™¶ç‰‡ä¸Šï¼Œå¤§å¹…æå‡äº†é›»è…¦çš„æ€§èƒ½å’Œå¯é æ€§ã€‚', hint: 'å¾®é›»å­æŠ€è¡“é‡è¦çªç ´', colorIndex: 6 },
            { id: 'card-mouse', type: 'ç™¼æ˜', name: 'é›»è…¦æ»‘é¼ ', year: 1964, description: 'é“æ ¼æ‹‰æ–¯Â·æ©æ ¼çˆ¾å·´ç‰¹ç™¼æ˜ï¼Œé©å‘½æ€§åœ°æ”¹è®Šäº†äººæ©Ÿäº’å‹•æ–¹å¼ï¼Œè®“é›»è…¦æ›´å®¹æ˜“ä½¿ç”¨ã€‚', hint: 'æ”¹è®Šäººæ©Ÿäº’å‹•çš„è¨­å‚™', colorIndex: 7 },
            { id: 'card-moore', type: 'äººç‰©', name: 'æˆˆç™»Â·æ‘©çˆ¾', year: 1965, description: 'è‹±ç‰¹çˆ¾å‰µè¾¦äººï¼Œæå‡ºæ‘©çˆ¾å®šå¾‹ï¼Œé æ¸¬æ™¶ç‰‡æ€§èƒ½æ¯å…©å¹´ç¿»å€ï¼Œè‡³ä»Šä»æŒ‡å°è‘—åŠå°é«”ç”¢æ¥­ã€‚', hint: 'é æ¸¬æ™¶ç‰‡ç™¼å±•çš„å®šå¾‹æå‡ºè€…', colorIndex: 0 },
            { id: 'card-arpanet', type: 'ç™¼æ˜', name: 'ARPANET', year: 1969, description: 'ç¶²éš›ç¶²è·¯çš„å‰èº«ï¼Œç¬¬ä¸€å€‹å°åŒ…äº¤æ›ç¶²è·¯ï¼Œé€£æ¥äº†å››æ‰€ç¾åœ‹å¤§å­¸ï¼Œé–‹å•Ÿäº†ç¶²è·¯æ™‚ä»£ã€‚', hint: 'ç¶²éš›ç¶²è·¯çš„å‰èº«', colorIndex: 1 },
            
            // Microcomputer Revolution (1970s-1980s)
            { id: 'card-microprocessor', type: 'ç™¼æ˜', name: 'å¾®è™•ç†å™¨', year: 1971, description: 'Intel 4004ï¼Œç¬¬ä¸€æ¬¾å•†ç”¨å¾®è™•ç†å™¨ï¼Œé–‹å‰µäº†å€‹äººé›»è…¦æ™‚ä»£çš„æŠ€è¡“åŸºç¤ã€‚', hint: 'å€‹äººé›»è…¦æ™‚ä»£çš„æ ¸å¿ƒæŠ€è¡“', colorIndex: 2 },
            { id: 'card-floppy', type: 'ç™¼æ˜', name: 'è»Ÿç¢Ÿ', year: 1971, description: 'IBMç™¼æ˜ï¼Œæä¾›äº†å¯æ”œå¼è³‡æ–™å„²å­˜æ–¹å¼ï¼Œè®“ç¨‹å¼å’Œè³‡æ–™èƒ½åœ¨ä¸åŒé›»è…¦é–“è½‰ç§»ã€‚', hint: 'ç¬¬ä¸€ç¨®å¯æ”œå¼å„²å­˜åª’é«”', colorIndex: 3 },
            { id: 'card-gates', type: 'äººç‰©', name: 'æ¯”çˆ¾Â·è“‹èŒ²', year: 1975, description: 'Microsoftå‰µè¾¦äººï¼Œæ¨å‹•äº†å€‹äººé›»è…¦è»Ÿé«”çš„æ™®åŠï¼Œè®“é›»è…¦æˆç‚ºæ¯å€‹äººéƒ½èƒ½ä½¿ç”¨çš„å·¥å…·ã€‚', hint: 'è»Ÿé«”å·¨é ­å…¬å¸å‰µè¾¦äºº', colorIndex: 4 },
            { id: 'card-jobs', type: 'äººç‰©', name: 'å²è’‚å¤«Â·è³ˆä¼¯æ–¯', year: 1976, description: 'è˜‹æœé›»è…¦å‰µè¾¦äººï¼Œä»¥ç”¨æˆ¶é«”é©—ç‚ºä¸­å¿ƒçš„è¨­è¨ˆç†å¿µï¼Œé©å‘½æ€§åœ°æ”¹è®Šäº†å€‹äººé›»è…¦ç”¢æ¥­ã€‚', hint: 'é‡è¦–è¨­è¨ˆçš„é›»è…¦å…¬å¸å‰µè¾¦äºº', colorIndex: 5 },
            { id: 'card-apple2', type: 'ç™¼æ˜', name: 'Apple II', year: 1977, description: 'ç¬¬ä¸€å°æˆåŠŸçš„å€‹äººé›»è…¦ï¼Œé…å‚™å½©è‰²é¡¯ç¤ºå’Œè²éŸ³åŠŸèƒ½ï¼Œè®“é›»è…¦èµ°å…¥å®¶åº­ã€‚', hint: 'æˆåŠŸçš„å®¶ç”¨å€‹äººé›»è…¦', colorIndex: 6 },
            { id: 'card-ada-lang', type: 'ç™¼æ˜', name: 'Adaç¨‹å¼èªè¨€', year: 1980, description: 'ç¾åœ‹åœ‹é˜²éƒ¨å°‡å…¶é›»è…¦ç¨‹å¼èªè¨€ä»¥ã€ŒAdaã€å‘½åï¼Œä»¥ç´€å¿µæ„›é”Â·å‹’èŠ™è•¾çµ²é€™ä½ä¸–ç•Œç¬¬ä¸€ä½ç¨‹å¼è¨­è¨ˆå¸«ã€‚', hint: 'ç´€å¿µé¦–ä½ç¨‹å¼è¨­è¨ˆå¸«çš„èªè¨€', colorIndex: 7 },
            
            // Personal Computer Popularization (1980s-1990s)
            { id: 'card-ibm-pc', type: 'ç™¼æ˜', name: 'IBM PC', year: 1981, description: 'å»ºç«‹äº†å€‹äººé›»è…¦çš„å·¥æ¥­æ¨™æº–ï¼Œé–‹å‰µäº†PCå…¼å®¹æ©Ÿçš„æ™‚ä»£ã€‚', hint: 'å€‹äººé›»è…¦å·¥æ¥­æ¨™æº–åˆ¶å®šè€…', colorIndex: 0 },
            { id: 'card-lotus', type: 'ç™¼æ˜', name: 'Lotus 1-2-3', year: 1983, description: 'IBM PCçš„ç¬¬ä¸€å€‹æ®ºæ‰‹ç´šæ‡‰ç”¨ç¨‹å¼ï¼Œé›»å­è©¦ç®—è¡¨è»Ÿé«”ï¼Œæ¨å‹•äº†å•†æ¥­é›»è…¦åŒ–ã€‚', hint: 'ç¬¬ä¸€å€‹æ®ºæ‰‹ç´šæ‡‰ç”¨ç¨‹å¼', colorIndex: 1 },
            { id: 'card-mac', type: 'ç™¼æ˜', name: 'Macintosh', year: 1984, description: 'ç¬¬ä¸€å°æˆåŠŸå•†æ¥­åŒ–çš„åœ–å½¢ä½¿ç”¨è€…ä»‹é¢é›»è…¦ï¼Œæ”¹è®Šäº†äººèˆ‡é›»è…¦çš„äº’å‹•æ–¹å¼ã€‚', hint: 'åœ–å½¢ä»‹é¢çš„å…ˆé©…é›»è…¦', colorIndex: 2 },
            { id: 'card-windows', type: 'ç™¼æ˜', name: 'Windows 1.0', year: 1985, description: 'Microsoftæ¨å‡ºçš„ç¬¬ä¸€å€‹åœ–å½¢ä½¿ç”¨è€…ä»‹é¢ä½œæ¥­ç³»çµ±ï¼Œè®“DOSé›»è…¦ä¹Ÿèƒ½ä½¿ç”¨åœ–å½¢ç•Œé¢ã€‚', hint: 'æ™®åŠåœ–å½¢ä»‹é¢çš„ä½œæ¥­ç³»çµ±', colorIndex: 3 },
            
            // Internet Era (1990s-2000s)
            { id: 'card-www', type: 'ç™¼æ˜', name: 'World Wide Web', year: 1989, description: 'æå§†Â·æŸç´æ–¯-æç™¼æ˜è¬ç¶­ç¶²ï¼Œå¾¹åº•æ”¹è®Šäº†è³‡è¨Šå‚³æ’­æ–¹å¼ï¼Œé–‹å•Ÿäº†ç¶²éš›ç¶²è·¯æ™‚ä»£ã€‚', hint: 'æ”¹è®Šä¸–ç•Œçš„ç¶²è·¯ç™¼æ˜', colorIndex: 4 },
            { id: 'card-linux', type: 'ç™¼æ˜', name: 'Linux', year: 1991, description: 'æ—ç´æ–¯Â·æ‰˜ç“¦èŒ²é–‹ç™¼çš„é–‹æºä½œæ¥­ç³»çµ±ï¼Œæ¨å‹•äº†é–‹æºè»Ÿé«”é‹å‹•ï¼Œæˆç‚ºä¼ºæœå™¨ä¸»æµç³»çµ±ã€‚', hint: 'é–‹æºè»Ÿé«”é‹å‹•çš„ä»£è¡¨', colorIndex: 5 },
            { id: 'card-mosaic', type: 'ç™¼æ˜', name: 'Mosaicç€è¦½å™¨', year: 1993, description: 'ç¬¬ä¸€å€‹åœ–å½¢åŒ–ç¶²é ç€è¦½å™¨ï¼Œè®“ä¸€èˆ¬å¤§çœ¾èƒ½å¤ è¼•é¬†ä½¿ç”¨ç¶²éš›ç¶²è·¯ã€‚', hint: 'ç¬¬ä¸€å€‹åœ–å½¢åŒ–ç€è¦½å™¨', colorIndex: 6 },
            { id: 'card-google', type: 'ç™¼æ˜', name: 'Googleæœå°‹å¼•æ“', year: 1998, description: 'æ”¹è®Šè³‡è¨Šæª¢ç´¢æ–¹å¼ï¼Œè®“ç¶²è·¯ä¸Šçš„é¾å¤§è³‡è¨Šè®Šå¾—æ˜“æ–¼æœå°‹å’Œå­˜å–ã€‚', hint: 'æ”¹è®Šæœå°‹æ–¹å¼çš„å¼•æ“', colorIndex: 7 },
            
            // Mobile and Cloud Era (2000s-2010s)
            { id: 'card-iphone', type: 'ç™¼æ˜', name: 'iPhone', year: 2007, description: 'è˜‹æœæ¨å‡ºçš„æ™ºæ…§æ‰‹æ©Ÿï¼Œè§¸æ§è¢å¹•å’Œç›´è§€ä»‹é¢é©å‘½æ€§åœ°æ”¹è®Šäº†è¡Œå‹•é€šè¨Šã€‚', hint: 'è§¸æ§é©å‘½çš„æ™ºæ…§æ‰‹æ©Ÿ', colorIndex: 0 },
            { id: 'card-android', type: 'ç™¼æ˜', name: 'Android', year: 2008, description: 'Googleé–‹ç™¼çš„é–‹æºè¡Œå‹•ä½œæ¥­ç³»çµ±ï¼Œæ¨å‹•äº†æ™ºæ…§æ‰‹æ©Ÿçš„æ™®åŠã€‚', hint: 'é–‹æºçš„è¡Œå‹•ä½œæ¥­ç³»çµ±', colorIndex: 1 },
            { id: 'card-ipad', type: 'ç™¼æ˜', name: 'iPad', year: 2010, description: 'é–‹å‰µäº†å¹³æ¿é›»è…¦å¸‚å ´ï¼Œæ”¹è®Šäº†äººå€‘æ¶ˆè²»åª’é«”å…§å®¹å’Œè¼•åº¦è¨ˆç®—çš„æ–¹å¼ã€‚', hint: 'é–‹å‰µå¹³æ¿é›»è…¦å¸‚å ´', colorIndex: 2 },
            
            // AI and Modern Technology (2020s)
            { id: 'card-chatgpt', type: 'ç™¼æ˜', name: 'ChatGPT', year: 2022, description: 'OpenAIæ¨å‡ºçš„å°è©±å¼AIï¼Œè®“äººå·¥æ™ºæ…§æŠ€è¡“é€²å…¥å¤§çœ¾ç”Ÿæ´»ï¼Œé–‹å•ŸAIæ™‚ä»£ã€‚', hint: 'å°è©±å¼AIé€²å…¥å¤§çœ¾ç”Ÿæ´»', colorIndex: 3 }
          ]
        };

        const ComputerHistoryTimeline = () => {
          const [timelineScale, setTimelineScale] = useState(1);
          const [timelineOffset, setTimelineOffset] = useState(0);
          const [cards, setCards] = useState(configData.historyCards);
          const [placedCards, setPlacedCards] = useState([]);
          const [draggedCard, setDraggedCard] = useState(null);
          const [isDragging, setIsDragging] = useState(false);
          const [popupCard, setPopupCard] = useState(null);
          const [popupPosition, setPopupPosition] = useState({ x: 0, y: 0 });
          const [isTimelineDragging, setIsTimelineDragging] = useState(false);
          const [dragStart, setDragStart] = useState({ x: 0, offset: 0 });
          const [errorMessage, setErrorMessage] = useState('');
          const [timelineHeight, setTimelineHeight] = useState(60);
          const [isResizing, setIsResizing] = useState(false);
          const timelineRef = useRef(null);
          
          // è§¸æ§æ‹–æ‹½ç›¸é—œç‹€æ…‹
          const [touchDragCard, setTouchDragCard] = useState(null);
          const [touchDragPosition, setTouchDragPosition] = useState({ x: 0, y: 0 });
          const [touchStartPosition, setTouchStartPosition] = useState({ x: 0, y: 0 });
          const [isTouchDragging, setIsTouchDragging] = useState(false);
          
          // è§¸æ§ç¸®æ”¾ç›¸é—œç‹€æ…‹
          const [lastTouchDistance, setLastTouchDistance] = useState(0);
          const [lastTouchCenter, setLastTouchCenter] = useState({ x: 0, y: 0 });

          const minYear = 1600;
          const maxYear = 2030;
          const yearRange = maxYear - minYear;

          // åˆå§‹åŒ–æ™‚é–“è»¸é¡¯ç¤ºæ•´å€‹å¹´ä»½ç¯„åœ
          useEffect(() => {
            if (timelineRef.current && timelineScale === 1 && timelineOffset === 0) {
              const containerWidth = timelineRef.current.clientWidth;
              const timelineWidth = 2000 * timelineScale;
              
              // å¦‚æœæ™‚é–“è»¸æ¯”å®¹å™¨å¯¬ï¼Œå‰‡å±…ä¸­é¡¯ç¤º
              if (timelineWidth > containerWidth) {
                const centerOffset = (containerWidth - timelineWidth) / 2;
                setTimelineOffset(centerOffset);
              } else {
                // å¦‚æœæ™‚é–“è»¸æ¯”å®¹å™¨çª„ï¼Œå‰‡èª¿æ•´ç¸®æ”¾ä»¥é©æ‡‰å®¹å™¨
                const newScale = containerWidth / 2000;
                setTimelineScale(newScale);
                setTimelineOffset(0);
              }
            }
          }, [timelineRef.current]);

          // è¨ˆç®—å…©é»é–“è·é›¢ï¼ˆç”¨æ–¼è§¸æ§ç¸®æ”¾ï¼‰
          const getTouchDistance = (touch1, touch2) => {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
          };

          // è¨ˆç®—å…©é»ä¸­å¿ƒï¼ˆç”¨æ–¼è§¸æ§ç¸®æ”¾ï¼‰
          const getTouchCenter = (touch1, touch2) => {
            return {
              x: (touch1.clientX + touch2.clientX) / 2,
              y: (touch1.clientY + touch2.clientY) / 2
            };
          };

          // Generate dynamic year markers based on zoom level
          const generateYearMarkers = () => {
            let interval;
            
            if (timelineScale >= 2.5) {
              interval = 10;
            } else if (timelineScale >= 1.5) {
              interval = 25;
            } else if (timelineScale >= 0.8) {
              interval = 50;
            } else {
              interval = 100;
            }
            
            const markers = [];
            const startYear = Math.ceil(minYear / interval) * interval;
            
            for (let year = startYear; year <= maxYear; year += interval) {
              markers.push(year);
            }
            
            return markers;
          };

          const dynamicYearMarkers = generateYearMarkers();

          const yearToPixel = (year) => {
            const ratio = (year - minYear) / yearRange;
            return ratio * 2000 * timelineScale + timelineOffset;
          };

          const pixelToYear = (pixel) => {
            const ratio = (pixel - timelineOffset) / (2000 * timelineScale);
            return Math.round(minYear + ratio * yearRange);
          };

          // è™•ç†æ»‘é¼ æ»¾è¼ªç¸®æ”¾
          const handleTimelineZoom = (event) => {
            event.preventDefault();
            const delta = event.deltaY * -0.001;
            const newScale = Math.max(0.5, Math.min(3, timelineScale + delta));
            
            if (newScale !== timelineScale && timelineRef.current) {
              const rect = timelineRef.current.getBoundingClientRect();
              const mouseX = event.clientX - rect.left;
              const scaleRatio = newScale / timelineScale;
              const newOffset = mouseX - (mouseX - timelineOffset) * scaleRatio;
              
              setTimelineScale(newScale);
              setTimelineOffset(newOffset);
            }
          };

          // è™•ç†è§¸æ§ç¸®æ”¾é–‹å§‹
          const handleTouchStart = (e) => {
            if (e.touches.length === 2) {
              // é›™æŒ‡è§¸æ§ç¸®æ”¾
              e.preventDefault();
              const distance = getTouchDistance(e.touches[0], e.touches[1]);
              const center = getTouchCenter(e.touches[0], e.touches[1]);
              setLastTouchDistance(distance);
              setLastTouchCenter(center);
            } else if (e.touches.length === 1) {
              // å–®æŒ‡æ‹–æ‹½æ™‚é–“è»¸ï¼ˆå¦‚æœé»æ“Šåœ¨æ™‚é–“è»¸èƒŒæ™¯ä¸Šï¼‰
              if (e.target === timelineRef.current || e.target.classList.contains('timeline-background')) {
                setIsTimelineDragging(true);
                setDragStart({
                  x: e.touches[0].clientX,
                  offset: timelineOffset
                });
                setPopupCard(null);
              }
            }
          };

          // è™•ç†è§¸æ§ç¸®æ”¾ç§»å‹•
          const handleTouchMove = (e) => {
            if (e.touches.length === 2) {
              // é›™æŒ‡ç¸®æ”¾
              e.preventDefault();
              const distance = getTouchDistance(e.touches[0], e.touches[1]);
              const center = getTouchCenter(e.touches[0], e.touches[1]);
              
              if (lastTouchDistance > 0 && timelineRef.current) {
                const scaleChange = distance / lastTouchDistance;
                const newScale = Math.max(0.5, Math.min(3, timelineScale * scaleChange));
                
                if (newScale !== timelineScale) {
                  const rect = timelineRef.current.getBoundingClientRect();
                  const centerX = center.x - rect.left;
                  const scaleRatio = newScale / timelineScale;
                  const newOffset = centerX - (centerX - timelineOffset) * scaleRatio;
                  
                  setTimelineScale(newScale);
                  setTimelineOffset(newOffset);
                }
                
                setLastTouchDistance(distance);
                setLastTouchCenter(center);
              }
            } else if (e.touches.length === 1 && isTimelineDragging) {
              // å–®æŒ‡æ‹–æ‹½æ™‚é–“è»¸
              const deltaX = e.touches[0].clientX - dragStart.x;
              setTimelineOffset(dragStart.offset + deltaX);
            }
          };

          // è™•ç†è§¸æ§çµæŸ
          const handleTouchEnd = (e) => {
            if (e.touches.length < 2) {
              setLastTouchDistance(0);
            }
            if (e.touches.length === 0) {
              setIsTimelineDragging(false);
            }
          };

          // è™•ç†å¡ç‰‡è§¸æ§é–‹å§‹
          const handleCardTouchStart = (e, card) => {
            e.preventDefault();
            e.stopPropagation();
            
            const touch = e.touches[0];
            setTouchDragCard(card);
            setTouchStartPosition({ x: touch.clientX, y: touch.clientY });
            setTouchDragPosition({ x: touch.clientX, y: touch.clientY });
            setIsTouchDragging(false);
            setPopupCard(null);
          };

          // è™•ç†å¡ç‰‡è§¸æ§ç§»å‹•
          const handleCardTouchMove = (e) => {
            if (!touchDragCard) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartPosition.x);
            const deltaY = Math.abs(touch.clientY - touchStartPosition.y);
            
            // å¦‚æœç§»å‹•è·é›¢è¶…éé–¾å€¼ï¼Œé–‹å§‹æ‹–æ‹½
            if (!isTouchDragging && (deltaX > 10 || deltaY > 10)) {
              setIsTouchDragging(true);
              setIsDragging(true);
              setDraggedCard(touchDragCard);
            }
            
            if (isTouchDragging) {
              setTouchDragPosition({ x: touch.clientX, y: touch.clientY });
            }
          };

          // è™•ç†å¡ç‰‡è§¸æ§çµæŸ
          const handleCardTouchEnd = (e) => {
            if (!touchDragCard) return;
            
            e.preventDefault();
            
            if (isTouchDragging && timelineRef.current) {
              // æª¢æŸ¥æ˜¯å¦æ”¾ç½®åœ¨æ™‚é–“è»¸ä¸Š
              const timelineRect = timelineRef.current.getBoundingClientRect();
              const touch = e.changedTouches[0];
              
              if (touch.clientY >= timelineRect.top && touch.clientY <= timelineRect.bottom &&
                  touch.clientX >= timelineRect.left && touch.clientX <= timelineRect.right) {
                
                const dropX = touch.clientX - timelineRect.left;
                const dropYear = pixelToYear(dropX);
                const correctYear = touchDragCard.year;
                const yearDifference = Math.abs(dropYear - correctYear);
                
                if (yearDifference <= 25) {
                  // æ­£ç¢ºæ”¾ç½®
                  if (cards.find(card => card.id === touchDragCard.id)) {
                    setCards(cards.filter(card => card.id !== touchDragCard.id));
                    const newCard = { ...touchDragCard, placedYear: correctYear };
                    setPlacedCards([...placedCards, newCard]);
                    
                    setTimeout(() => {
                      const cardPixelX = yearToPixel(correctYear);
                      setPopupPosition({
                        x: timelineRect.left + cardPixelX,
                        y: timelineRect.top + timelineRect.height * 0.3
                      });
                      setPopupCard(newCard);
                    }, 100);
                  }
                } else {
                  // éŒ¯èª¤æ”¾ç½®
                  setErrorMessage(`è«‹å˜—è©¦å°‡ã€Œ${touchDragCard.name}ã€æ”¾ç½®åˆ°æ›´æ¥è¿‘å…¶æ­£ç¢ºå¹´ä»£çš„ä½ç½®ï¼æ­£ç¢ºå¹´ä»£æ˜¯${correctYear}å¹´ã€‚`);
                }
              }
            } else if (!isTouchDragging) {
              // å¦‚æœæ²’æœ‰æ‹–æ‹½ï¼Œå‰‡è¦–ç‚ºé»æ“Š
              if (placedCards.find(c => c.id === touchDragCard.id)) {
                // é¡¯ç¤ºå½ˆçª—
                const rect = e.target.getBoundingClientRect();
                setPopupPosition({
                  x: rect.left + rect.width / 2,
                  y: rect.top - 10
                });
                setPopupCard(touchDragCard);
              }
            }
            
            // é‡ç½®è§¸æ§ç‹€æ…‹
            setTouchDragCard(null);
            setIsTouchDragging(false);
            setIsDragging(false);
            setDraggedCard(null);
          };

          // Handle timeline drag start
          const handleTimelineMouseDown = (e) => {
            if (e.target === timelineRef.current || e.target.classList.contains('timeline-background')) {
              setIsTimelineDragging(true);
              setDragStart({
                x: e.clientX,
                offset: timelineOffset
              });
              setPopupCard(null);
            }
          };

          // Handle timeline drag move
          const handleTimelineMouseMove = (e) => {
            if (isTimelineDragging) {
              const deltaX = e.clientX - dragStart.x;
              setTimelineOffset(dragStart.offset + deltaX);
            }
          };

          // Handle timeline drag end
          const handleTimelineMouseUp = () => {
            setIsTimelineDragging(false);
          };

          // Handle resizer drag
          const handleResizerMouseDown = (e) => {
            setIsResizing(true);
            e.preventDefault();
          };

          const handleResizerMouseMove = (e) => {
            if (isResizing) {
              const windowHeight = window.innerHeight;
              const headerHeight = 120;
              const newHeight = ((e.clientY - headerHeight) / (windowHeight - headerHeight)) * 100;
              setTimelineHeight(Math.max(30, Math.min(80, newHeight)));
            }
          };

          const handleResizerMouseUp = () => {
            setIsResizing(false);
          };

          // Add global event listeners
          useEffect(() => {
            if (isTimelineDragging) {
              document.addEventListener('mousemove', handleTimelineMouseMove);
              document.addEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'grabbing';
            } else {
              document.removeEventListener('mousemove', handleTimelineMouseMove);
              document.removeEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'default';
            }

            return () => {
              document.removeEventListener('mousemove', handleTimelineMouseMove);
              document.removeEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'default';
            };
          }, [isTimelineDragging, dragStart]);

          // Add resizer event listeners
          useEffect(() => {
            if (isResizing) {
              document.addEventListener('mousemove', handleResizerMouseMove);
              document.addEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'ns-resize';
            } else {
              document.removeEventListener('mousemove', handleResizerMouseMove);
              document.removeEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'default';
            }

            return () => {
              document.removeEventListener('mousemove', handleResizerMouseMove);
              document.removeEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'default';
            };
          }, [isResizing]);

          // Auto-hide error message after 3 seconds
          useEffect(() => {
            if (errorMessage) {
              const timer = setTimeout(() => {
                setErrorMessage('');
              }, 3000);
              return () => clearTimeout(timer);
            }
          }, [errorMessage]);

          // Handle drag start (æ»‘é¼ æ‹–æ‹½)
          const handleDragStart = (e, card) => {
            setDraggedCard(card);
            setIsDragging(true);
            setPopupCard(null);
            setErrorMessage('');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', card.id);
          };

          // Handle drag end
          const handleDragEnd = () => {
            setDraggedCard(null);
            setIsDragging(false);
          };

          // Handle timeline drop (æ»‘é¼ æ‹–æ‹½)
          const handleTimelineDrop = (e) => {
            e.preventDefault();
            if (!draggedCard) return;

            const timelineRect = timelineRef.current.getBoundingClientRect();
            const dropX = e.clientX - timelineRect.left;
            const dropYear = pixelToYear(dropX);

            const correctYear = draggedCard.year;
            const yearDifference = Math.abs(dropYear - correctYear);
            
            if (yearDifference <= 25) {
              if (cards.find(card => card.id === draggedCard.id)) {
                setCards(cards.filter(card => card.id !== draggedCard.id));
                const newCard = { ...draggedCard, placedYear: correctYear };
                setPlacedCards([...placedCards, newCard]);
                
                setTimeout(() => {
                  const cardPixelX = yearToPixel(correctYear);
                  setPopupPosition({
                    x: timelineRect.left + cardPixelX,
                    y: timelineRect.top + timelineRect.height * 0.3
                  });
                  setPopupCard(newCard);
                }, 100);
              }
            } else {
              setErrorMessage(`è«‹å˜—è©¦å°‡ã€Œ${draggedCard.name}ã€æ”¾ç½®åˆ°æ›´æ¥è¿‘å…¶æ­£ç¢ºå¹´ä»£çš„ä½ç½®ï¼æ­£ç¢ºå¹´ä»£æ˜¯${correctYear}å¹´ã€‚`);
            }

            setDraggedCard(null);
            setIsDragging(false);
          };

          // Handle library drop
          const handleLibraryDrop = (e) => {
            e.preventDefault();
            if (!draggedCard || cards.find(card => card.id === draggedCard.id)) return;

            setPlacedCards(placedCards.filter(card => card.id !== draggedCard.id));
            setCards([...cards, draggedCard]);
            setPopupCard(null);

            setDraggedCard(null);
            setIsDragging(false);
          };

          // Prevent default drag behaviors
          const handleDragOver = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          };

          const handleDragEnter = (e) => {
            e.preventDefault();
          };

          const handleDragLeave = (e) => {
            e.preventDefault();
          };

          // Handle card click to show popup (åªç”¨æ–¼æ»‘é¼ é»æ“Š)
          const handleCardClick = (e, card) => {
            e.stopPropagation();
            if (isTimelineDragging) return;
            
            if (placedCards.find(c => c.id === card.id)) {
              const rect = e.currentTarget.getBoundingClientRect();
              setPopupPosition({
                x: rect.left + rect.width / 2,
                y: rect.top - 10
              });
              setPopupCard(card);
            }
          };

          // Close popup
          const closePopup = () => {
            setPopupCard(null);
          };

          // Card component
          const Card = ({ card, isPlaced = false, placedYear = null }) => {
            const colorStyle = stickyColors[card.colorIndex % stickyColors.length];
            const isCurrentlyDragging = isDragging && (draggedCard?.id === card.id || touchDragCard?.id === card.id);
            const cardScale = isPlaced ? Math.min(1.5, Math.max(0.8, timelineScale)) : 1;
            
            return (
              <div
                draggable={!('ontouchstart' in window)} // åªåœ¨éè§¸æ§è¨­å‚™ä¸Šå•Ÿç”¨HTML5æ‹–æ‹½
                onDragStart={(e) => handleDragStart(e, card)}
                onDragEnd={handleDragEnd}
                onClick={(e) => handleCardClick(e, card)}
                onTouchStart={(e) => handleCardTouchStart(e, card)}
                onTouchMove={handleCardTouchMove}
                onTouchEnd={handleCardTouchEnd}
                className={`p-3 rounded-lg shadow-md cursor-move transition-all hover:shadow-xl select-none transform hover:scale-105 no-select ${
                  colorStyle.bg
                } ${colorStyle.border} ${colorStyle.hover} ${
                  isCurrentlyDragging ? 'opacity-50 rotate-6 scale-110' : ''
                } ${isPlaced ? 'm-1' : 'm-1'}`}
                style={{
                  transform: isCurrentlyDragging 
                    ? `rotate(${Math.random() * 4 - 2}deg) scale(1.1)` 
                    : `rotate(${Math.random() * 4 - 2}deg) scale(${cardScale})`,
                  boxShadow: '0 4px 8px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08)',
                  minHeight: isPlaced ? `${80 * cardScale}px` : '90px',
                  fontSize: isPlaced ? `${cardScale * 14}px` : '14px'
                }}
              >
                <div className={`text-xs font-bold mb-1 ${
                  card.type === 'äººç‰©' ? 'text-blue-800' : 'text-purple-800'
                }`}>
                  {card.type}
                </div>
                <div className="text-sm font-semibold text-gray-800 mb-1 leading-tight">{card.name}</div>
                {isPlaced && (
                  <div className="text-xs text-gray-600">
                    {placedYear || card.year}å¹´
                  </div>
                )}
                {!isPlaced && (
                  <div className="text-xs text-gray-500 italic">
                    {card.hint}
                  </div>
                )}
              </div>
            );
          };

          // è§¸æ§æ‹–æ‹½é è¦½
          const TouchDragPreview = () => {
            if (!isTouchDragging || !touchDragCard) return null;
            
            const colorStyle = stickyColors[touchDragCard.colorIndex % stickyColors.length];
            
            return (
              <div
                className={`touch-drag-preview p-3 rounded-lg shadow-lg ${colorStyle.bg} ${colorStyle.border}`}
                style={{
                  left: touchDragPosition.x - 50,
                  top: touchDragPosition.y - 50,
                  transform: 'rotate(5deg) scale(1.1)',
                  minHeight: '90px',
                  width: '100px'
                }}
              >
                <div className={`text-xs font-bold mb-1 ${
                  touchDragCard.type === 'äººç‰©' ? 'text-blue-800' : 'text-purple-800'
                }`}>
                  {touchDragCard.type}
                </div>
                <div className="text-sm font-semibold text-gray-800 mb-1 leading-tight">{touchDragCard.name}</div>
              </div>
            );
          };

          // Popup component
          const PopupDetail = () => {
            if (!popupCard) return null;

            return (
              <>
                <div 
                  className="fixed inset-0 z-40"
                  onClick={closePopup}
                  onTouchStart={closePopup}
                />
                
                <div 
                  className="fixed z-50 bg-white rounded-lg shadow-2xl border-2 border-gray-200 p-4 max-w-xs"
                  style={{
                    left: `${popupPosition.x}px`,
                    top: `${popupPosition.y}px`,
                    transform: 'translate(-50%, -100%)',
                    boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)'
                  }}
                >
                  <div 
                    className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0"
                    style={{
                      borderLeft: '8px solid transparent',
                      borderRight: '8px solid transparent',
                      borderTop: '8px solid white'
                    }}
                  />
                  
                  <div className="mb-3">
                    <span className={`px-2 py-1 rounded text-xs font-bold ${
                      popupCard.type === 'äººç‰©' ? 'bg-blue-100 text-blue-800' : 'bg-purple-100 text-purple-800'
                    }`}>
                      {popupCard.type}
                    </span>
                  </div>
                  
                  <h3 className="text-lg font-bold mb-2 text-gray-800">{popupCard.name}</h3>
                  
                  <p className="text-sm text-gray-600 mb-3">
                    å¹´ä»½: {popupCard.year}å¹´
                  </p>
                  
                  <p className="text-sm text-gray-800 mb-4">{popupCard.description}</p>
                  
                  <button
                    onClick={() => {
                      setPlacedCards(placedCards.filter(card => card.id !== popupCard.id));
                      setCards([...cards, popupCard]);
                      closePopup();
                    }}
                    className="w-full px-3 py-2 bg-red-500 text-white rounded text-sm hover:bg-red-600 transition-colors"
                  >
                    ç§»é™¤æ­¤å¡ç‰‡
                  </button>
                </div>
              </>
            );
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
              {/* Header */}
              <div className="bg-white shadow-lg">
                <h1 className="text-3xl font-bold text-center py-4 text-gray-800">
                  é›»è…¦ç§‘æŠ€ç™¼å±•æ­·å²æ™‚é–“è»¸
                </h1>
                <div className="text-center pb-4">
                  <span className="inline-block bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm mr-2">
                    âœ¨ 38å¼µæ­·å²å¡ç‰‡
                  </span>
                  <span className="inline-block bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm mr-2">
                    ğŸ“… 1600-2030å¹´é›»è…¦ç™¼å±•å²
                  </span>
                  <span className="inline-block bg-orange-100 text-orange-800 px-3 py-1 rounded-full text-sm">
                    ğŸ“± è§¸æ§å‹å–„
                  </span>
                </div>
              </div>

              {/* Error message display */}
              {errorMessage && (
                <div className="fixed top-24 left-1/2 transform -translate-x-1/2 z-50 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded shadow-lg max-w-md">
                  <div className="flex items-center">
                    <span className="text-xl mr-2">âŒ</span>
                    <span>{errorMessage}</span>
                  </div>
                </div>
              )}

              <div className="flex flex-col h-screen">
                {/* Timeline area */}
                <div className="p-6" style={{ height: `${timelineHeight}vh` }}>
                  <div className="bg-white rounded-lg shadow-lg h-full">
                    <div className="p-4 border-b">
                      <h2 className="text-xl font-bold">â° æ™‚é–“è»¸</h2>
                      <p className="text-sm text-gray-600">
                        æ ¹æ“šæç¤ºæ‹–æ‹½å¡ç‰‡åˆ°æ­£ç¢ºçš„æ™‚é–“ä½ç½® â€¢ é»æ“Šå·²æ”¾ç½®çš„å¡ç‰‡æŸ¥çœ‹è©³æƒ… â€¢ æ»‘é¼ æ»¾è¼ªæˆ–é›™æŒ‡ç¸®æ”¾ â€¢ æ‹–æ‹½æ™‚é–“è»¸å¹³ç§»
                      </p>
                    </div>
                    
                    <div 
                      className={`relative overflow-hidden flex-1 timeline-background no-select ${
                        isTimelineDragging ? 'cursor-grabbing' : 'cursor-grab'
                      }`}
                      style={{ 
                        height: 'calc(100% - 120px)',
                        background: 'linear-gradient(to right, #f8fafc, #f1f5f9)'
                      }}
                      onWheel={handleTimelineZoom}
                      onDrop={handleTimelineDrop}
                      onDragOver={handleDragOver}
                      onDragEnter={handleDragEnter}
                      onDragLeave={handleDragLeave}
                      onMouseDown={handleTimelineMouseDown}
                      onTouchStart={handleTouchStart}
                      onTouchMove={handleTouchMove}
                      onTouchEnd={handleTouchEnd}
                      onClick={closePopup}
                      ref={timelineRef}
                    >
                      {/* Timeline main line */}
                      <div 
                        className="absolute top-1/2 h-2 bg-gradient-to-r from-blue-400 to-blue-600 transform -translate-y-1/2 rounded-full shadow-md pointer-events-none"
                        style={{ 
                          left: `${timelineOffset}px`,
                          width: `${2000 * timelineScale}px`
                        }}
                      ></div>
                      
                      {/* Year markers */}
                      {dynamicYearMarkers.map(year => {
                        const xPos = yearToPixel(year);
                        const containerWidth = timelineRef.current ? timelineRef.current.clientWidth : 800;
                        if (xPos < -100 || xPos > containerWidth + 100) return null;
                        
                        return (
                          <div 
                            key={year}
                            className="absolute top-1/2 transform -translate-y-1/2 pointer-events-none"
                            style={{ left: `${xPos}px` }}
                          >
                            <div className="w-4 h-4 bg-blue-600 rounded-full -translate-x-1/2 shadow-lg border-2 border-white"></div>
                            <div className="text-sm font-bold mt-3 -translate-x-1/2 whitespace-nowrap text-center bg-white px-2 py-1 rounded shadow-sm">
                              {year}
                            </div>
                          </div>
                        );
                      })}

                      {/* Placed cards */}
                      {placedCards.map(card => {
                        const xPos = yearToPixel(card.placedYear);
                        return (
                          <div
                            key={card.id}
                            className="absolute pointer-events-auto"
                            style={{ 
                              left: `${xPos}px`, 
                              top: '30%',
                              transform: 'translateX(-50%)' 
                            }}
                            onMouseDown={(e) => e.stopPropagation()}
                            onTouchStart={(e) => e.stopPropagation()}
                          >
                            <Card card={card} isPlaced={true} placedYear={card.placedYear} />
                          </div>
                        );
                      })}
                    </div>

                    {/* Control panel */}
                    <div className="p-4 border-t bg-gray-50">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-6">
                          <span className="text-sm font-medium text-gray-600">
                            ç¸®æ”¾: {(timelineScale * 100).toFixed(0)}%
                          </span>
                          <span className="text-xs text-gray-500">
                            ğŸ’¡ æ»‘é¼ æ»¾è¼ª/é›™æŒ‡ç¸®æ”¾ â€¢ æ‹–æ‹½æ™‚é–“è»¸å¹³ç§» â€¢ å¹´ä»½æ¨™è¨˜éš¨ç¸®æ”¾è‡ªå‹•èª¿æ•´
                          </span>
                        </div>
                        <button
                          onClick={() => {
                            setTimelineScale(1);
                            setTimelineOffset(0);
                          }}
                          className="px-4 py-2 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600 transition-colors shadow-sm"
                        >
                          ğŸ”„ é‡ç½®æ™‚é–“è»¸
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Resizer */}
                <div 
                  className="resizer"
                  onMouseDown={handleResizerMouseDown}
                ></div>

                {/* Card library */}
                <div className="bg-white shadow-lg border-t" style={{ height: `${100 - timelineHeight}vh` }}>
                  <div 
                    className="h-full"
                    onDrop={handleLibraryDrop}
                    onDragOver={handleDragOver}
                    onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                  >
                    <div className="flex items-center justify-between p-4 bg-gradient-to-r from-gray-50 to-gray-100 border-b">
                      <h2 className="text-xl font-bold text-gray-800">ğŸ“š æ­·å²å¡ç‰‡åº«</h2>
                      <div className="text-sm text-gray-600">
                        å‰©é¤˜ {cards.length} å¼µå¡ç‰‡
                      </div>
                    </div>
                    
                    <div className="p-6 overflow-y-auto bg-gray-50" style={{ height: 'calc(100% - 80px)' }}>
                      {cards.length === 0 ? (
                        <div className="flex items-center justify-center h-full text-gray-500 text-center">
                          <div className="bg-white rounded-lg p-8 shadow-md">
                            <div className="text-4xl mb-3">ğŸ‰</div>
                            <div className="text-lg font-medium">å®Œæˆï¼</div>
                            <div className="text-sm">æ‰€æœ‰å¡ç‰‡éƒ½å·²æ­£ç¢ºæ”¾ç½®åˆ°æ™‚é–“è»¸ä¸Š</div>
                          </div>
                        </div>
                      ) : (
                        <div>
                          {/* Person cards section */}
                          {cards.filter(card => card.type === 'äººç‰©').length > 0 && (
                            <div className="mb-6">
                              <h3 className="text-sm font-bold text-blue-800 mb-3 flex items-center">
                                ğŸ‘¤ é‡è¦äººç‰© ({cards.filter(card => card.type === 'äººç‰©').length})
                              </h3>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
                                {cards.filter(card => card.type === 'äººç‰©').map(card => (
                                  <Card key={card.id} card={card} />
                                ))}
                              </div>
                            </div>
                          )}
                          
                          {/* Invention cards section */}
                          {cards.filter(card => card.type === 'ç™¼æ˜').length > 0 && (
                            <div>
                              <h3 className="text-sm font-bold text-purple-800 mb-3 flex items-center">
                                ğŸ’¡ é‡è¦ç™¼æ˜ ({cards.filter(card => card.type === 'ç™¼æ˜').length})
                              </h3>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
                                {cards.filter(card => card.type === 'ç™¼æ˜').map(card => (
                                  <Card key={card.id} card={card} />
                                ))}
                              </div>
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>

              {/* Touch drag preview */}
              <TouchDragPreview />

              {/* Popup detail */}
              <PopupDetail />
            </div>
          );
        };

        ReactDOM.render(<ComputerHistoryTimeline />, document.getElementById('root'));
    </script>
</body>
</html>
