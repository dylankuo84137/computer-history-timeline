<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>電腦科技發展歷史時間軸</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .timeline-background {
            background: linear-gradient(to right, #f8fafc, #f1f5f9);
        }
        .resizer {
            background: #e5e7eb;
            cursor: ns-resize;
            height: 8px;
            position: relative;
        }
        .resizer:hover {
            background: #9ca3af;
        }
        .resizer::after {
            content: '⋯⋯⋯';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b7280;
            font-size: 12px;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Color configuration for sticky note cards
        const stickyColors = [
          { bg: 'bg-yellow-200', border: 'border-yellow-400', hover: 'hover:bg-yellow-300' },
          { bg: 'bg-pink-200', border: 'border-pink-400', hover: 'hover:bg-pink-300' },
          { bg: 'bg-blue-200', border: 'border-blue-400', hover: 'hover:bg-blue-300' },
          { bg: 'bg-green-200', border: 'border-green-400', hover: 'hover:bg-green-300' },
          { bg: 'bg-purple-200', border: 'border-purple-400', hover: 'hover:bg-purple-300' },
          { bg: 'bg-orange-200', border: 'border-orange-400', hover: 'hover:bg-orange-300' },
          { bg: 'bg-indigo-200', border: 'border-indigo-400', hover: 'hover:bg-indigo-300' },
          { bg: 'bg-red-200', border: 'border-red-400', hover: 'hover:bg-red-300' }
        ];

        /*
         * CONFIGURATION DATA - Computer History Timeline (17th Century to Modern Era)
         * 
         * How to edit the card library:
         * 1. Find the configData object below
         * 2. Add new cards to the historyCards array
         * 3. Card format: { id: 'unique-id', type: 'Person|Invention', name: 'Name', year: YYYY, description: 'Description', colorIndex: 0-7 }
         * 4. Year format: Use AD years (e.g., 1990 for year 1990 AD)
         * 5. Modify timeline: Add new years to timelineMarkers array
         * 6. colorIndex: 0-7 corresponds to different sticky note colors
         * 7. Card types: Support 'Person' (人物) and 'Invention' (發明) types
         */
        const configData = {
          timelineMarkers: [
            // Important time nodes from 17th century to modern era
            1600, 1650, 1700, 1750, 1800, 1850, 1900, 1920, 1940, 1960, 1980, 2000, 2020
          ],
          historyCards: [
            // 17th Century Computing Machines (1600s)
            { id: 'card-17th-1', type: '人物', name: '理查·布雷斯韋特', year: 1613, description: '首次記錄「電腦 (computer)」一詞，當時指從事計算工作的人，而非機器。', colorIndex: 2 },
            { id: 'card-17th-2', type: '人物', name: '布萊茲·帕斯卡', year: 1642, description: '發明手搖計算器 (Pascaline)，最初只能做加法，後來改良可做減法和乘法。', colorIndex: 3 },
            { id: 'card-17th-3', type: '人物', name: '戈特弗里德·萊布尼茨', year: 1694, description: '建造了步進計算器 (Step Reckoner)，第一台可以自動執行加減乘除四種運算的機器，並發明了萊布尼茨輪。', colorIndex: 4 },
            
            // 19th Century Babbage Era (1800s)
            { id: 'card-babbage-1', type: '人物', name: '查爾斯·巴貝奇', year: 1822, description: '電腦之父，提出差分計算機設計，旨在自動化微積分計算以生成可靠的數學表格。', colorIndex: 5 },
            { id: 'card-babbage-2', type: '發明', name: '分析機 (Analytical Engine)', year: 1837, description: '巴貝奇設計的通用計算機起點，具備資料儲存、運算、輸入和輸出的概念，是現代電腦架構的先驅。', colorIndex: 6 },
            { id: 'card-ada-1', type: '人物', name: '愛達·勒芙蕾絲', year: 1833, description: '17歲時在巴貝奇的沙龍中認識了他，對差分機展現出極大興趣，開啟了程式設計史。', colorIndex: 7 },
            { id: 'card-ada-2', type: '發明', name: '第一個電腦程式', year: 1843, description: '愛達·勒芙蕾絲為分析機編寫計算白努利數的演算法，使用了迴圈和次常式等現代程式設計技巧，被視為史上第一個公開發表的電腦程式。', colorIndex: 0 },
            { id: 'card-diff-2', type: '發明', name: '差分機二號', year: 1847, description: '巴貝奇設計的零件更精簡、可計算31位數的差分機，展現了機械計算的極致。', colorIndex: 1 },
            { id: 'card-scheutz', type: '人物', name: '佩爾·格奧爾格·舒茲', year: 1855, description: '瑞典發明家，受巴貝奇啟發成功建造並在巴黎萬國博覽會展出全尺寸差分機。', colorIndex: 2 },
            
            // Beginning of Electrical Era (Late 1800s)
            { id: 'card-tesla', type: '人物', name: '尼古拉·特斯拉', year: 1888, description: '發明高頻交流發電機，使人類正式邁入電氣時代，為後來的電子計算機奠定基礎。', colorIndex: 3 },
            { id: 'card-hollerith', type: '人物', name: '赫爾曼·何樂禮', year: 1890, description: '現代機械數據處理之父，為美國人口普查設計了電力製表系統，利用打孔卡和電路元件，比人工計算快約10倍。', colorIndex: 4 },
            
            // 20th Century Theoretical Foundation (1900s-1930s)
            { id: 'card-ibm', type: '發明', name: 'IBM公司成立', year: 1924, description: '何樂禮的製表機械公司最終發展為萬國商業機械公司 (IBM)，成為電腦產業的重要推手。', colorIndex: 5 },
            { id: 'card-turing', type: '人物', name: '艾倫·圖靈', year: 1936, description: '提出圖靈機概念，為現代電腦科學和人工智慧奠定了理論基礎。', colorIndex: 6 },
            { id: 'card-shannon', type: '人物', name: '克勞德·夏農', year: 1937, description: '21歲時發表《繼電器和開關電路的符號分析》論文，被視為數位計算機理論和數位電路設計理論的創始人。', colorIndex: 7 },
            { id: 'card-ww2', type: '發明', name: '二戰推動電腦發展', year: 1939, description: '第二次世界大戰的爆發推動了軍事和科技競爭，促成了第一台電子電腦的誕生。', colorIndex: 0 },
            
            // Electronic Computer Era (1940s-1950s)
            { id: 'card-neumann', type: '人物', name: '約翰·馮·諾伊曼', year: 1945, description: '提出馮諾伊曼架構，這個架構至今仍是大多數電腦系統的基礎設計原理。', colorIndex: 1 },
            { id: 'card-eniac', type: '發明', name: 'ENIAC', year: 1946, description: '第一台真正的電子數位計算機，重達30噸，佔地167平方米，標誌著電腦時代的開始。', colorIndex: 2 },
            { id: 'card-transistor', type: '發明', name: '電晶體', year: 1947, description: '貝爾實驗室發明，取代真空管的革命性發明，使電腦變得更小、更快、更可靠。', colorIndex: 3 },
            { id: 'card-univac', type: '發明', name: 'UNIVAC I', year: 1951, description: '第一台商用電腦，成功預測了艾森豪威爾的總統選舉勝利，向公眾展示了電腦的威力。', colorIndex: 4 },
            { id: 'card-ada-reprint', type: '發明', name: '愛達筆記再版', year: 1953, description: '愛達·勒芙蕾絲關於巴貝奇分析機的筆記被重新出版，提升了其在電腦發展史上的地位。', colorIndex: 5 },
            
            // Modern Computer Development (1950s-1970s)
            { id: 'card-ic', type: '發明', name: '集成電路', year: 1958, description: '德州儀器發明，將多個電晶體集成在一個晶片上，大幅提升了電腦的性能和可靠性。', colorIndex: 6 },
            { id: 'card-mouse', type: '發明', name: '電腦滑鼠', year: 1964, description: '道格拉斯·恩格爾巴特發明，革命性地改變了人機互動方式，讓電腦更容易使用。', colorIndex: 7 },
            { id: 'card-moore', type: '人物', name: '戈登·摩爾', year: 1965, description: '英特爾創辦人，提出摩爾定律，預測晶片性能每兩年翻倍，至今仍指導著半導體產業。', colorIndex: 0 },
            { id: 'card-arpanet', type: '發明', name: 'ARPANET', year: 1969, description: '網際網路的前身，第一個封包交換網路，連接了四所美國大學，開啟了網路時代。', colorIndex: 1 },
            
            // Microcomputer Revolution (1970s-1980s)
            { id: 'card-microprocessor', type: '發明', name: '微處理器', year: 1971, description: 'Intel 4004，第一款商用微處理器，開創了個人電腦時代的技術基礎。', colorIndex: 2 },
            { id: 'card-floppy', type: '發明', name: '軟碟', year: 1971, description: 'IBM發明，提供了可攜式資料儲存方式，讓程式和資料能在不同電腦間轉移。', colorIndex: 3 },
            { id: 'card-gates', type: '人物', name: '比爾·蓋茲', year: 1975, description: 'Microsoft創辦人，推動了個人電腦軟體的普及，讓電腦成為每個人都能使用的工具。', colorIndex: 4 },
            { id: 'card-jobs', type: '人物', name: '史蒂夫·賈伯斯', year: 1976, description: '蘋果電腦創辦人，以用戶體驗為中心的設計理念，革命性地改變了個人電腦產業。', colorIndex: 5 },
            { id: 'card-apple2', type: '發明', name: 'Apple II', year: 1977, description: '第一台成功的個人電腦，配備彩色顯示和聲音功能，讓電腦走入家庭。', colorIndex: 6 },
            { id: 'card-ada-lang', type: '發明', name: 'Ada程式語言', year: 1980, description: '美國國防部將其電腦程式語言以「Ada」命名，以紀念愛達·勒芙蕾絲這位世界第一位程式設計師。', colorIndex: 7 },
            
            // Personal Computer Popularization (1980s-1990s)
            { id: 'card-ibm-pc', type: '發明', name: 'IBM PC', year: 1981, description: '建立了個人電腦的工業標準，開創了PC兼容機的時代。', colorIndex: 0 },
            { id: 'card-lotus', type: '發明', name: 'Lotus 1-2-3', year: 1983, description: 'IBM PC的第一個殺手級應用程式，電子試算表軟體，推動了商業電腦化。', colorIndex: 1 },
            { id: 'card-mac', type: '發明', name: 'Macintosh', year: 1984, description: '第一台成功商業化的圖形使用者介面電腦，改變了人與電腦的互動方式。', colorIndex: 2 },
            { id: 'card-windows', type: '發明', name: 'Windows 1.0', year: 1985, description: 'Microsoft推出的第一個圖形使用者介面作業系統，讓DOS電腦也能使用圖形界面。', colorIndex: 3 },
            
            // Internet Era (1990s-2000s)
            { id: 'card-www', type: '發明', name: 'World Wide Web', year: 1989, description: '提姆·柏納斯-李發明萬維網，徹底改變了資訊傳播方式，開啟了網際網路時代。', colorIndex: 4 },
            { id: 'card-linux', type: '發明', name: 'Linux', year: 1991, description: '林納斯·托瓦茲開發的開源作業系統，推動了開源軟體運動，成為伺服器主流系統。', colorIndex: 5 },
            { id: 'card-mosaic', type: '發明', name: 'Mosaic瀏覽器', year: 1993, description: '第一個圖形化網頁瀏覽器，讓一般大眾能夠輕鬆使用網際網路。', colorIndex: 6 },
            { id: 'card-google', type: '發明', name: 'Google搜尋引擎', year: 1998, description: '改變資訊檢索方式，讓網路上的龐大資訊變得易於搜尋和存取。', colorIndex: 7 },
            
            // Mobile and Cloud Era (2000s-2010s)
            { id: 'card-iphone', type: '發明', name: 'iPhone', year: 2007, description: '蘋果推出的智慧手機，觸控螢幕和直觀介面革命性地改變了行動通訊。', colorIndex: 0 },
            { id: 'card-android', type: '發明', name: 'Android', year: 2008, description: 'Google開發的開源行動作業系統，推動了智慧手機的普及。', colorIndex: 1 },
            { id: 'card-ipad', type: '發明', name: 'iPad', year: 2010, description: '開創了平板電腦市場，改變了人們消費媒體內容和輕度計算的方式。', colorIndex: 2 },
            
            // AI and Modern Technology (2020s)
            { id: 'card-chatgpt', type: '發明', name: 'ChatGPT', year: 2022, description: 'OpenAI推出的對話式AI，讓人工智慧技術進入大眾生活，開啟AI時代。', colorIndex: 3 }
          ]
        };

        const ComputerHistoryTimeline = () => {
          const [timelineScale, setTimelineScale] = useState(1);
          const [timelineOffset, setTimelineOffset] = useState(0);
          const [cards, setCards] = useState(configData.historyCards);
          const [placedCards, setPlacedCards] = useState([]);
          const [draggedCard, setDraggedCard] = useState(null);
          const [isDragging, setIsDragging] = useState(false);
          const [popupCard, setPopupCard] = useState(null);
          const [popupPosition, setPopupPosition] = useState({ x: 0, y: 0 });
          const [isTimelineDragging, setIsTimelineDragging] = useState(false);
          const [dragStart, setDragStart] = useState({ x: 0, offset: 0 });
          const [errorMessage, setErrorMessage] = useState('');
          const [timelineHeight, setTimelineHeight] = useState(60); // Percentage of screen height
          const [isResizing, setIsResizing] = useState(false);
          const timelineRef = useRef(null);

          // Timeline configuration - focused on 17th century to modern era
          const minYear = 1600;  // Starting from 17th century
          const maxYear = 2030;  // Until year 2030
          const yearRange = maxYear - minYear;

          // Convert year to pixel position (linear)
          const yearToPixel = (year) => {
            const ratio = (year - minYear) / yearRange;
            return ratio * 2000 * timelineScale + timelineOffset;
          };

          // Convert pixel position to year (linear)
          const pixelToYear = (pixel) => {
            const ratio = (pixel - timelineOffset) / (2000 * timelineScale);
            return Math.round(minYear + ratio * yearRange);
          };

          // Handle timeline zoom - centered on mouse position
          const handleTimelineZoom = (event) => {
            event.preventDefault();
            const delta = event.deltaY * -0.001;
            const newScale = Math.max(0.5, Math.min(3, timelineScale + delta));
            
            if (newScale !== timelineScale && timelineRef.current) {
              // Get mouse position in timeline
              const rect = timelineRef.current.getBoundingClientRect();
              const mouseX = event.clientX - rect.left;
              
              // Calculate scale ratio change
              const scaleRatio = newScale / timelineScale;
              
              // Calculate new offset to keep mouse position year unchanged
              const newOffset = mouseX - (mouseX - timelineOffset) * scaleRatio;
              
              // Update state
              setTimelineScale(newScale);
              setTimelineOffset(newOffset);
            }
          };

          // Handle timeline drag start
          const handleTimelineMouseDown = (e) => {
            // Only start dragging timeline when clicking on empty area
            if (e.target === timelineRef.current || e.target.classList.contains('timeline-background')) {
              setIsTimelineDragging(true);
              setDragStart({
                x: e.clientX,
                offset: timelineOffset
              });
              setPopupCard(null); // Close any open popup
            }
          };

          // Handle timeline drag move
          const handleTimelineMouseMove = (e) => {
            if (isTimelineDragging) {
              const deltaX = e.clientX - dragStart.x;
              setTimelineOffset(dragStart.offset + deltaX);
            }
          };

          // Handle timeline drag end
          const handleTimelineMouseUp = () => {
            setIsTimelineDragging(false);
          };

          // Handle resizer drag
          const handleResizerMouseDown = (e) => {
            setIsResizing(true);
            e.preventDefault();
          };

          const handleResizerMouseMove = (e) => {
            if (isResizing) {
              const windowHeight = window.innerHeight;
              const headerHeight = 120; // Approximate header height
              const newHeight = ((e.clientY - headerHeight) / (windowHeight - headerHeight)) * 100;
              setTimelineHeight(Math.max(30, Math.min(80, newHeight))); // Limit between 30% and 80%
            }
          };

          const handleResizerMouseUp = () => {
            setIsResizing(false);
          };

          // Add global event listeners
          useEffect(() => {
            if (isTimelineDragging) {
              document.addEventListener('mousemove', handleTimelineMouseMove);
              document.addEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'grabbing';
            } else {
              document.removeEventListener('mousemove', handleTimelineMouseMove);
              document.removeEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'default';
            }

            return () => {
              document.removeEventListener('mousemove', handleTimelineMouseMove);
              document.removeEventListener('mouseup', handleTimelineMouseUp);
              document.body.style.cursor = 'default';
            };
          }, [isTimelineDragging, dragStart]);

          // Add resizer event listeners
          useEffect(() => {
            if (isResizing) {
              document.addEventListener('mousemove', handleResizerMouseMove);
              document.addEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'ns-resize';
            } else {
              document.removeEventListener('mousemove', handleResizerMouseMove);
              document.removeEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'default';
            }

            return () => {
              document.removeEventListener('mousemove', handleResizerMouseMove);
              document.removeEventListener('mouseup', handleResizerMouseUp);
              document.body.style.cursor = 'default';
            };
          }, [isResizing]);

          // Add global drag end listeners
          useEffect(() => {
            const handleGlobalDragEnd = () => {
              if (isDragging) {
                setDraggedCard(null);
                setIsDragging(false);
              }
            };

            document.addEventListener('dragend', handleGlobalDragEnd);
            document.addEventListener('drop', handleGlobalDragEnd);

            return () => {
              document.removeEventListener('dragend', handleGlobalDragEnd);
              document.removeEventListener('drop', handleGlobalDragEnd);
            };
          }, [isDragging]);

          // Auto-hide error message after 3 seconds
          useEffect(() => {
            if (errorMessage) {
              const timer = setTimeout(() => {
                setErrorMessage('');
              }, 3000);
              return () => clearTimeout(timer);
            }
          }, [errorMessage]);

          // Handle drag start
          const handleDragStart = (e, card) => {
            setDraggedCard(card);
            setIsDragging(true);
            setPopupCard(null); // Close popup
            setErrorMessage(''); // Clear any error message
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', card.id);
          };

          // Handle drag end
          const handleDragEnd = () => {
            setDraggedCard(null);
            setIsDragging(false);
          };

          // Handle timeline drop
          const handleTimelineDrop = (e) => {
            e.preventDefault();
            if (!draggedCard) return;

            const timelineRect = timelineRef.current.getBoundingClientRect();
            const dropX = e.clientX - timelineRect.left;
            const dropYear = pixelToYear(dropX);

            // Check if dropped within 25 years of correct year
            const correctYear = draggedCard.year;
            const yearDifference = Math.abs(dropYear - correctYear);
            
            if (yearDifference <= 25) {
              // Correct placement - snap to correct year and show popup
              if (cards.find(card => card.id === draggedCard.id)) {
                setCards(cards.filter(card => card.id !== draggedCard.id));
                const newCard = { ...draggedCard, placedYear: correctYear };
                setPlacedCards([...placedCards, newCard]);
                
                // Show popup immediately for correct placement
                setTimeout(() => {
                  const cardPixelX = yearToPixel(correctYear);
                  setPopupPosition({
                    x: timelineRect.left + cardPixelX,
                    y: timelineRect.top + timelineRect.height * 0.3
                  });
                  setPopupCard(newCard);
                }, 100);
              }
            } else {
              // Incorrect placement - show error message
              setErrorMessage(`請嘗試將「${draggedCard.name}」放置到更接近其正確年代的位置！正確年代是${correctYear}年。`);
            }

            // Clear dragging state
            setDraggedCard(null);
            setIsDragging(false);
          };

          // Handle library drop
          const handleLibraryDrop = (e) => {
            e.preventDefault();
            if (!draggedCard || cards.find(card => card.id === draggedCard.id)) return;

            setPlacedCards(placedCards.filter(card => card.id !== draggedCard.id));
            setCards([...cards, draggedCard]);
            setPopupCard(null);

            // Clear dragging state
            setDraggedCard(null);
            setIsDragging(false);
          };

          // Prevent default drag behaviors
          const handleDragOver = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          };

          const handleDragEnter = (e) => {
            e.preventDefault();
          };

          const handleDragLeave = (e) => {
            e.preventDefault();
          };

          // Handle card click to show popup (only for placed cards)
          const handleCardClick = (e, card) => {
            e.stopPropagation();
            // Prevent triggering during timeline dragging
            if (isTimelineDragging) return;
            
            if (placedCards.find(c => c.id === card.id)) {
              const rect = e.currentTarget.getBoundingClientRect();
              setPopupPosition({
                x: rect.left + rect.width / 2,
                y: rect.top - 10
              });
              setPopupCard(card);
            }
          };

          // Close popup
          const closePopup = () => {
            setPopupCard(null);
          };

          // Card component
          const Card = ({ card, isPlaced = false, placedYear = null }) => {
            const colorStyle = stickyColors[card.colorIndex % stickyColors.length];
            const isCurrentlyDragging = isDragging && draggedCard?.id === card.id;
            
            // Calculate card scale based on timeline scale for placed cards
            const cardScale = isPlaced ? Math.min(1.5, Math.max(0.8, timelineScale)) : 1;
            
            return (
              <div
                draggable
                onDragStart={(e) => handleDragStart(e, card)}
                onDragEnd={handleDragEnd}
                onClick={(e) => handleCardClick(e, card)}
                className={`p-3 rounded-lg shadow-md cursor-move transition-all hover:shadow-xl select-none transform hover:scale-105 ${
                  colorStyle.bg
                } ${colorStyle.border} ${colorStyle.hover} ${
                  isCurrentlyDragging ? 'opacity-50 rotate-6 scale-110' : ''
                } ${isPlaced ? 'm-1' : 'm-1'}`}
                style={{
                  transform: isCurrentlyDragging 
                    ? `rotate(${Math.random() * 4 - 2}deg) scale(1.1)` 
                    : `rotate(${Math.random() * 4 - 2}deg) scale(${cardScale})`,
                  boxShadow: '0 4px 8px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08)',
                  minHeight: isPlaced ? `${80 * cardScale}px` : '90px',
                  fontSize: isPlaced ? `${cardScale * 14}px` : '14px'
                }}
              >
                <div className={`text-xs font-bold mb-1 ${
                  card.type === '人物' ? 'text-blue-800' : 'text-purple-800'
                }`}>
                  {card.type}
                </div>
                <div className="text-sm font-semibold text-gray-800 mb-1 leading-tight">{card.name}</div>
                {/* Hide year for unplaced cards, show for placed cards */}
                {isPlaced && (
                  <div className="text-xs text-gray-600">
                    {placedYear || card.year}年
                  </div>
                )}
                {!isPlaced && (
                  <div className="text-xs text-gray-400">
                    拖拽到時間軸
                  </div>
                )}
              </div>
            );
          };

          // Popup component
          const PopupDetail = () => {
            if (!popupCard) return null;

            return (
              <>
                {/* Overlay */}
                <div 
                  className="fixed inset-0 z-40"
                  onClick={closePopup}
                />
                
                {/* Popup content */}
                <div 
                  className="fixed z-50 bg-white rounded-lg shadow-2xl border-2 border-gray-200 p-4 max-w-xs"
                  style={{
                    left: `${popupPosition.x}px`,
                    top: `${popupPosition.y}px`,
                    transform: 'translate(-50%, -100%)',
                    boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)'
                  }}
                >
                  {/* Arrow */}
                  <div 
                    className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0"
                    style={{
                      borderLeft: '8px solid transparent',
                      borderRight: '8px solid transparent',
                      borderTop: '8px solid white'
                    }}
                  />
                  
                  <div className="mb-3">
                    <span className={`px-2 py-1 rounded text-xs font-bold ${
                      popupCard.type === '人物' ? 'bg-blue-100 text-blue-800' : 'bg-purple-100 text-purple-800'
                    }`}>
                      {popupCard.type}
                    </span>
                  </div>
                  
                  <h3 className="text-lg font-bold mb-2 text-gray-800">{popupCard.name}</h3>
                  
                  <p className="text-sm text-gray-600 mb-3">
                    年份: {popupCard.year}年
                  </p>
                  
                  <p className="text-sm text-gray-800 mb-4">{popupCard.description}</p>
                  
                  <button
                    onClick={() => {
                      setPlacedCards(placedCards.filter(card => card.id !== popupCard.id));
                      setCards([...cards, popupCard]);
                      closePopup();
                    }}
                    className="w-full px-3 py-2 bg-red-500 text-white rounded text-sm hover:bg-red-600 transition-colors"
                  >
                    移除此卡片
                  </button>
                </div>
              </>
            );
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
              {/* Header */}
              <div className="bg-white shadow-lg">
                <h1 className="text-3xl font-bold text-center py-4 text-gray-800">
                  電腦科技發展歷史時間軸
                </h1>
                <div className="text-center pb-4">
                  <span className="inline-block bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm mr-2">
                    ✨ 38張歷史卡片
                  </span>
                  <span className="inline-block bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">
                    📅 1600-2030年電腦發展史
                  </span>
                </div>
              </div>

              {/* Error message display */}
              {errorMessage && (
                <div className="fixed top-32 left-1/2 transform -translate-x-1/2 z-50 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded shadow-lg max-w-md">
                  <div className="flex items-center">
                    <span className="text-xl mr-2">❌</span>
                    <span>{errorMessage}</span>
                  </div>
                </div>
              )}

              <div className="flex flex-col h-screen">
                {/* Timeline area - adjustable height */}
                <div className="p-6" style={{ height: `${timelineHeight}vh` }}>
                  <div className="bg-white rounded-lg shadow-lg h-full">
                    <div className="p-4 border-b">
                      <h2 className="text-xl font-bold">⏰ 時間軸</h2>
                      <p className="text-sm text-gray-600">
                        拖拽卡片到正確的時間位置 • 點擊已放置的卡片查看詳情 • 滑鼠滾輪縮放 • 拖拽時間軸平移
                      </p>
                    </div>
                    
                    <div 
                      className={`relative overflow-hidden flex-1 timeline-background ${
                        isTimelineDragging ? 'cursor-grabbing' : 'cursor-grab'
                      }`}
                      style={{ 
                        height: 'calc(100% - 120px)',
                        background: 'linear-gradient(to right, #f8fafc, #f1f5f9)'
                      }}
                      onWheel={handleTimelineZoom}
                      onDrop={handleTimelineDrop}
                      onDragOver={handleDragOver}
                      onDragEnter={handleDragEnter}
                      onDragLeave={handleDragLeave}
                      onMouseDown={handleTimelineMouseDown}
                      onClick={closePopup}
                      ref={timelineRef}
                    >
                      {/* Timeline main line */}
                      <div 
                        className="absolute top-1/2 h-2 bg-gradient-to-r from-blue-400 to-blue-600 transform -translate-y-1/2 rounded-full shadow-md pointer-events-none"
                        style={{ 
                          left: `${timelineOffset}px`,
                          width: `${2000 * timelineScale}px`
                        }}
                      ></div>
                      
                      {/* Year markers */}
                      {configData.timelineMarkers.map(year => {
                        const xPos = yearToPixel(year);
                        const containerWidth = timelineRef.current ? timelineRef.current.clientWidth : 800;
                        if (xPos < -100 || xPos > containerWidth + 100) return null;
                        
                        return (
                          <div 
                            key={year}
                            className="absolute top-1/2 transform -translate-y-1/2 pointer-events-none"
                            style={{ left: `${xPos}px` }}
                          >
                            <div className="w-4 h-4 bg-blue-600 rounded-full -translate-x-1/2 shadow-lg border-2 border-white"></div>
                            <div className="text-sm font-bold mt-3 -translate-x-1/2 whitespace-nowrap text-center bg-white px-2 py-1 rounded shadow-sm">
                              {year}
                            </div>
                          </div>
                        );
                      })}

                      {/* Placed cards */}
                      {placedCards.map(card => {
                        const xPos = yearToPixel(card.placedYear);
                        return (
                          <div
                            key={card.id}
                            className="absolute pointer-events-auto"
                            style={{ 
                              left: `${xPos}px`, 
                              top: '30%',
                              transform: 'translateX(-50%)' 
                            }}
                            onMouseDown={(e) => e.stopPropagation()} // Prevent triggering timeline drag
                          >
                            <Card card={card} isPlaced={true} placedYear={card.placedYear} />
                          </div>
                        );
                      })}

                      {/* No general drop hint - only show error messages when placement is incorrect */}
                    </div>

                    {/* Control panel */}
                    <div className="p-4 border-t bg-gray-50">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-6">
                          <span className="text-sm font-medium text-gray-600">
                            縮放: {(timelineScale * 100).toFixed(0)}%
                          </span>
                          <span className="text-xs text-gray-500">
                            💡 滑鼠滾輪縮放(以滑鼠為中心) • 拖拽時間軸平移
                          </span>
                        </div>
                        <button
                          onClick={() => {
                            setTimelineScale(1);
                            setTimelineOffset(0);
                          }}
                          className="px-4 py-2 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600 transition-colors shadow-sm"
                        >
                          🔄 重置時間軸
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Resizer */}
                <div 
                  className="resizer"
                  onMouseDown={handleResizerMouseDown}
                ></div>

                {/* Card library - adjustable height */}
                <div className="bg-white shadow-lg border-t" style={{ height: `${100 - timelineHeight}vh` }}>
                  <div 
                    className="h-full"
                    onDrop={handleLibraryDrop}
                    onDragOver={handleDragOver}
                    onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                  >
                    <div className="flex items-center justify-between p-4 bg-gradient-to-r from-gray-50 to-gray-100 border-b">
                      <h2 className="text-xl font-bold text-gray-800">📚 歷史卡片庫</h2>
                      <div className="text-sm text-gray-600">
                        剩餘 {cards.length} 張卡片
                      </div>
                    </div>
                    
                    <div className="p-6 overflow-y-auto bg-gray-50" style={{ height: 'calc(100% - 80px)' }}>
                      {cards.length === 0 ? (
                        <div className="flex items-center justify-center h-full text-gray-500 text-center">
                          <div className="bg-white rounded-lg p-8 shadow-md">
                            <div className="text-4xl mb-3">🎉</div>
                            <div className="text-lg font-medium">完成！</div>
                            <div className="text-sm">所有卡片都已正確放置到時間軸上</div>
                          </div>
                        </div>
                      ) : (
                        <div>
                          {/* Person cards section */}
                          {cards.filter(card => card.type === '人物').length > 0 && (
                            <div className="mb-6">
                              <h3 className="text-sm font-bold text-blue-800 mb-3 flex items-center">
                                👤 重要人物 ({cards.filter(card => card.type === '人物').length})
                              </h3>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
                                {cards.filter(card => card.type === '人物').map(card => (
                                  <Card key={card.id} card={card} />
                                ))}
                              </div>
                            </div>
                          )}
                          
                          {/* Invention cards section */}
                          {cards.filter(card => card.type === '發明').length > 0 && (
                            <div>
                              <h3 className="text-sm font-bold text-purple-800 mb-3 flex items-center">
                                💡 重要發明 ({cards.filter(card => card.type === '發明').length})
                              </h3>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
                                {cards.filter(card => card.type === '發明').map(card => (
                                  <Card key={card.id} card={card} />
                                ))}
                              </div>
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>

              {/* Popup detail */}
              <PopupDetail />
            </div>
          );
        };

        ReactDOM.render(<ComputerHistoryTimeline />, document.getElementById('root'));
    </script>
</body>
</html>
